@using Microsoft.Extensions.DependencyInjection
@using Microsoft.Extensions.Logging
@inject IServiceProvider ServiceProvider
@inject ILogger<DevToolsInitializer> Logger
@implements IAsyncDisposable

@code {
    private ReduxDevToolsModule? _devTools;

    /// <inheritdoc />
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Try to get DevTools from DI container
            // This won't throw if DevTools isn't registered
            _devTools = ServiceProvider.GetService<ReduxDevToolsModule>();
            
            if (_devTools != null)
            {
                Logger.LogInformation("ReduxDevToolsModule resolved successfully. Initializing DevTools...");
                
                // Get store and dispatcher and set them in DevTools
                var store = ServiceProvider.GetService<IStore>();
                var dispatcher = ServiceProvider.GetService<IDispatcher>();
                
                if (store != null && dispatcher != null)
                {
                    _devTools.SetStoreAndDispatcher(store, dispatcher);
                    
                    // Initialize DevTools after the first render
                    // This ensures the JS runtime is ready
                    await _devTools.InitAsync();
                    
                    Logger.LogInformation("DevTools initialized successfully.");
                }
                else
                {
                    Logger.LogError("Could not resolve IStore or IDispatcher from DI container. DevTools will not be available.");
                }
            }
            else
            {
                Logger.LogWarning(
                    "ReduxDevToolsModule not found in DI container. DevTools will not be available. " +
                    "To enable DevTools, add .AddDevToolsMiddleware() to your store configuration.");
            }
        }
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        // Clean up if needed
        await Task.CompletedTask;
    }
}