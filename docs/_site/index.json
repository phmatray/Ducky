{
  "general/README.html": {
    "href": "general/README.html",
    "title": "General Documentation | R3dux Documentation",
    "keywords": "General Documentation This is the overall documentation like architecture decisions and such. Highlights Architecture decisions Getting Started"
  },
  "general/about-docs/README.html": {
    "href": "general/about-docs/README.html",
    "title": "Using DocFx and Companion Tools to generate a Documentation website | R3dux Documentation",
    "keywords": "Using DocFx and Companion Tools to generate a Documentation website If you want an easy way to have a website with all your documentation coming from Markdown files and comments coming from code, you can use DocFx. The website generated by DocFx also includes fast search capabilities. There are some gaps in the DocFx solution, but we've provided companion tools that help you fill those gaps. Also see the blog post Providing quality documentation in your project with DocFx and Companion Tools for more explanation about the solution. Quick Start To get you started quickly from scratch, a QuickStart folder is provided which can be copied with some common folder, files and settings mentioned in the steps below. Copy the content from the QuickStart folder folder to your own repository to get started in minutes. Tip TLDR; If you want a really quick start using Azure DevOps and Azure App Service without reading the what and how, follow these steps: Azure DevOps: If you don't have it yet, create a project in Azure DevOps and create a Service Connection to your Azure environment. Clone the repository. QuickStart folder: Copy the contents of the QuickStart folder to the root of your repository, except for the docs folder if you already have one, the .gitignore and the README.md. Azure: Create a resource group in your Azure environment where the documentation website resources should be created. Create Azure resources: Fill in the default values in infrastructure/variables.tf and run the commands from Step 3 - Deploy Azure resources from your local machine to create the Azure Resources. Pipeline: Fill in the variables in samples/pipelines/azure-devops/documentation.yml, commit the changes and push the contents of the repository to your branch (possibly through a PR). Now you can create a pipeline in your Azure DevOps project that uses the samples/pipelines/azure-devops/documentation.yml and run it. Documents and projects folder structure The easiest is to work with a mono repository where documentation and code live together. If that's not the case in your situation but you still want to combine multiple repositories into one documentation website, you'll have to clone all repositories first to be able to combine the information. In this recipe we'll assume a monorepo is used. In the steps below we'll consider the generation of the documentation website from this content structure: ðŸ“‚QuickStart // root ðŸ“‚docs // documentation root ðŸ“‚.attachments // images and other attachments ðŸ“‚.docfx // docfx configuration files ðŸ“‚template // docfx template for website ðŸ“‚x-cross // cross reference configuration ðŸ“‚general // Sample general documentation ðŸ“‚images // root images for favicon.ico and logo.png ðŸ“‚services // Sample service documentation ðŸ“„.order // for ADO and TocGenerator. Determines order of files in a folder. ðŸ“„docfx.json // configuration of DocFx input and output ðŸ“„index.md // root document of the website ðŸ“„toc.yml // configuration of the top navigation of the website ðŸ“„web.config // IIS configuration ðŸ“‚src // Sample sources ðŸ“‚build // Shared compiler configuration settings ðŸ“‚DotNetCoreSampleWebAPI // Sample .NET web api ðŸ“„Directory.Build.props // Force settings in all child solutions/projects ðŸ“„index.md // documentation ðŸ“„.markdownlint.json // Configuration file for markdownlint tool ðŸ“„GenerateDocWebsite.cmd // Batchfile for running generation We'll be using the DocLinkChecker tool to validate all links in documentation and for orphaned attachments. That's the reason we have all attachments in the .attachments folder. In the generated website from the QuickStart folder you'll see that the hierarchies of documentation and references is combined in the left table of contents. This is achieved by the definition and use of x-cross\\toc.yml. If you don't want the hierarchies combined, just remove the folder and file from your environment and (re)generate the website. A .markdownlint.json is included with the contents below. The MD013 setting is set to false to prevent checking for maximum line length. You can modify this file to your likings to include or exclude certain tests. { \"MD013\": false } The contents of the /samples folder is explained in the recipe Deploy the DocFx Documentation website to an Azure Website automatically. Reference documentation from source code DocFx can generate reference documentation from code, where C# and Typescript are supported best at the moment. In the QuickStart folder we only used C# projects. For DocFx to generate quality reference documentation, quality triple slash-comments are required. See Triple-slash (///) Code Comments Support. To enforce this, it's a good idea to enforce the use of StyleCop. There are a few steps that will give you an easy start with this. First, you can use the Directory.Build.props file in the /src folder in combination with the files in the build/dotnet folder. By having this, you enforce StyleCop in all Visual Studio project files in it's sub folders with a configuration of which rules should be used or ignored. You can tailor this to your needs of course. For more information, see Customize your build and Use rule sets to group code analysis rules. To make sure developers are forced to add the triple-slash comments by throwing compiler errors and to have the proper settings for the generation of documentation XML-files, add the TreatWarningsAsErrors and GenerateDocumentationFile settings to every .csproj file. You can add that in the first PropertyGroup settings like this: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> ... <GenerateDocumentationFile>true</GenerateDocumentationFile> <TreatWarningsAsErrors>true</TreatWarningsAsErrors> </PropertyGroup> ... </Project> Now you are all set to generate documentation from your C# code. For more information about languages supported by DocFx and how to configure it, see Introduction to Multiple Languages Support. Note You can also add a PropertyGroup definition with the two settings in Directory.Build.props to have that settings in all projects. But in that case it will also be inherited in your Test projects. 1. Install DocFx and markdownlint-cli Go to the DocFx website to the Download section and download the latest version of DocFx. Go to the github page of markdownlint-cli to find download and install options. You can also use tools like Chocolatey to install: choco install docfx choco install markdownlint-cli 2. Configure DocFx Configuration for DocFx is done in a docs\\docfx.json file. Best is to store this file in the root of your docs folder. Note You can store the docfx.json somewhere else in the hierarchy, but then you need to provide the path of the file as an argument to the docfx command so it can be located. It can have side effects, like ~ not properly addressing the docs root. Below is a good configuration to start with, where documentation is in the /docs folder and the sources are in the /src folder: { \"metadata\": [ { \"src\": [ { \"src\": \"../src\", \"files\": [\"**.csproj\"], \"exclude\": [\"**/bin/**\", \"**/obj/**\", \"**/[Tt]ests/**\"] } ], \"dest\": \"./reference\", \"includePrivateMembers\": false, \"disableGitFeatures\": false, \"disableDefaultFilter\": false, \"noRestore\": false, \"namespaceLayout\": \"flattened\" } ], \"build\": { \"content\": [ { \"files\": [ \"*.{md,yml}\", \"general/**/*.{md,yml}\", \"services/**/*.{md,yml}\", \"reference/**/*.{md,yml}\", \".docfx/x-cross/toc.yml\" ] } ], \"resource\": [ { \"files\": [\".attachments/**\", \"**/.attachments/**\", \"**/images/**\"] }, { \"files\": [\"web.config\"] } ], \"dest\": \"_site\", \"globalMetadata\": { \"_appTitle\": \"QuickStart Documentation\", \"_appName\": \"QUickStart Documentation\", \"_appLogoPath\": \"images/logo.png\", \"_appFaviconPath\": \"images/favicon.ico\", \"_enableSearch\": true, \"_enableNewTab\": true }, \"template\": [\"default\", \".docfx/template\"], \"globalMetadataFiles\": [], \"fileMetadataFiles\": [], \"postProcessors\": [], \"noLangKeyword\": false, \"keepFileLink\": false, \"disableGitFeatures\": false, \"xrefService\": [\"https://xref.docs.microsoft.com/query?uid={uid}\"], \"markdownEngineName\": \"markdig\", \"markdownEngineProperties\": { \"markdigExtensions\": [ \"tasklists\", \"diagrams\" ] } } } 3. Setup some basic documents We suggest starting with a basic documentation structure in the /docs folder. In the provided QuickStart folder we have a basic setup. You can use templates like working agreements and such from the CSE Playbook. To have a proper landing page of your documentation website, you can use a markdown file called INDEX.MD in the root of your repository. Contents can be something like this: # QuickStart Documentation This is the landing page of the QuickStart Documentation website. You can add specific links that are important to provide direct access. > [!TIP] > Try not to duplicate the links on the top of the page, unless it really makes sense. To get started with the setup of this website, read the getting started document with the title [Using DocFx and Companion Tools](./README.md). ## Style of this website This documentation website is currently setup with the basics of the [DocFx Material](https://ovasquez.github.io/docfx-material/) style added with the Microsoft logo. The combination can be found in **/QuickStart/docfx/template**. Support for Mermaid and a copy-code button is added to the custom template as well. 4. Compile the companion tools and run them Note To explain each step, we'll be going through the various steps in the next few paragraphs. In the provided sample, a batch-file called GenerateDocWebsite.cmd is included. This script will take all the necessary steps to compile the tools, execute the checks, generate the table of contents and execute docfx to generate the website. To check for proper markdown formatting the markdownlint-cli tool is used. The command takes it's configuration from the .markdownlint.json file in the root of the project. To check all markdown files, simply execute this command: markdownlint **/*.md We're using the docfx-companion-tools for checking links and TOC generation. Check the install instructions how this can be done. The DocLinkChecker companion tool is used to validate what's in the docs folder. It validates links between documents and attachments in the docs folder and checks if there aren't orphaned attachments. An example of executing this tool, where the check of attachments is included: DocLinkChecker.exe -d ./docs -a The DocFxTocGenerator tool is needed to generate a table of contents for your documentation, so users can navigate between folders and documents. If you have compiled the tool, use this command to generate a table of content file toc.yml. To generate a table of contents with the use of the .order files for determining the sequence of articles and to automatically generate index.md documents if no default document is available in a folder, this command can be used: DocFxTocGeneration.exe -d ./docs -sri 5. Run DocFx to generate the website Run the docfx command to generate the website, by default in the _site folder. Tip If you want to check the website in your local environment, provide the --serve option to either the docfx command or the GenerateDocWebsite script. A small webserver is launched that hosts your website, which is accessible on localhost. Style of the website If you started with the QuickStart folder, the website is generated using a custom theme using material design and the Microsoft logo. The logo and favorite icon are images that are configured in docfx.json. You can change this to your likings. For more information see How-to: Create A Custom Template | DocFX website (dotnet.github.io). Deploy to an Azure Website After you completed the steps, you should have a default website generated in the _site folder. But of course, you want this to be accessible for everyone. So, the next step is to create for instance an Azure Website and have a process to automatically generate and deploy the contents to that website. That process is described in the recipe Deploy the DocFx Documentation website to an Azure Website automatically. References DocFX - static documentation generator Deploy the DocFx Documentation website to an Azure Website automatically Providing quality documentation in your project with DocFx and Companion Tools Monorepo For Beginners"
  },
  "general/about-docs/copy-code-button.html": {
    "href": "general/about-docs/copy-code-button.html",
    "title": "Copy code button | R3dux Documentation",
    "keywords": "Copy code button Styling and a script was added to show a \"Copy Code\" button on code blocks in the browser. You can see the result below. Once you have copied the code, the button is checked: The real thing On the website you can try it yourself: using System; namespace HelloWorld { class Program { static void Main(string[] args) { Console.WriteLine(\"Hello World!\"); } } }"
  },
  "general/about-docs/customize-look-and-feel.html": {
    "href": "general/about-docs/customize-look-and-feel.html",
    "title": "Customize the Look and Feel | R3dux Documentation",
    "keywords": "Customize the Look and Feel If you don't configure it, DocFx will generate a website with an out-of-the-box template. The website for this Quick Start is then generated to this: For this website we created a custom template with a few extra's. That results in this look-and-feel: In docs\\.docfx\\template you can find the custom template for generating the documentation website. The basic template is first referenced in docfx.json to apply the defaults. As second template our custom template is configured. This will add or overwrite files of the default, in our case at least main.css. In the template we also enabled diagram support through Mermaid in scripts.tmpl.partial. Material design We chose the DocFx Material Theme as a starting point of our custom template. The Material.zip was downloaded and extracted. It contains a modified styles\\main.css. Mermaid support To enable the rendering of Mermaid diagrams in the documentation website, the code below can be added to partials\\scripts.tmpl.partial. <!-- Support for diagrams (Mermaid). See https://mermaid.js.org/intro/n00b-gettingStarted.html --> <script type=\"module\"> import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); </script> By adding this, mermaid diagrams are rendered in the website. A sample Mermaid diagram could be something like: gantt title Example Gantt diagram with Mermaid dateFormat YYYY-MM-DD section Team 1 Research & requirements :done, a1, 2021-03-08, 2021-04-10 Review & documentation : after a1, 20d section Team 2 Implementation :crit, active, 2021-03-25 , 20d Testing :crit, 20d which will be rendered as: gantt title Example Gantt diagram with Mermaid dateFormat YYYY-MM-DD section Team 1 Research & requirements :done, a1, 2021-03-08, 2021-04-10 Review & documentation : after a1, 20d section Team 2 Implementation :crit, active, 2021-03-25 , 20d Testing :crit, 20d 'Copy code'-button It can be desirable to have a copy button on code blocks to copy the contents to the clipboard for easy re-use. We have added this solution to the template for the website. In the Styles folder two files were added: copyCodeButton.css and copyCodeButton.js. In partials\\scripts.tmpl.partial the JavaScript file is referenced: ... <script type=\"text/javascript\" src=\"{{_rel}}styles/copy-code-button.js\"></script> ... And in partials\\head.tmpl.partial the CSS file is referenced: ... <link rel=\"stylesheet\" href=\"{{_rel}}styles/copy-code-button.css\"> ... When this is added, code blocks will have a Copy-button like this: When a user clicks the Copy-button, the contents is copied into the clipboard and the icon changes for some time to indicate the copy was succesfull: The Logo The logo of the website is images\\logo.png. The configuration is done in docfx.json for both the logo to use and the favorite icon to use like this: \"globalMetadata\": { \"_appTitle\": \"QuickStart Documentation\", \"_appName\": \"QUickStart Documentation\", \"_appLogoPath\": \"images/logo.png\", \"_appFaviconPath\": \"images/favicon.ico\", \"_enableSearch\": true, \"_enableNewTab\": true } Header Bar Color If you want to change the color of the header bar, open styles\\main.css and modify the --header-bg-color value. If you want to make sure it's a web safe color, you can use a website like Color Tools.NET to make your selected color web safe."
  },
  "general/about-docs/deploy-docfx-azure-website.html": {
    "href": "general/about-docs/deploy-docfx-azure-website.html",
    "title": "Deploy the DocFx Documentation website to an Azure Website automatically | R3dux Documentation",
    "keywords": "Deploy the DocFx Documentation website to an Azure Website automatically In the README the process is described to generate content of a documentation website using DocFx. This document describes how to setup an Azure Website to host the content and automate the deployment to it using a pipeline in Azure DevOps. The QuickStart folder that is provided for a quick setup of DocFx generation also contains the files explained in this document. Especially the .pipelines and infrastructure folders. The following steps can be followed when using the QuickStart folder. In the infrastructure folder you can find the Terraform files to create the website in an Azure environment. Out of the box, the script will create a website where the documentation content can be deployed to. 1. Install Terraform You can use tools like Chocolatey to install Terraform: choco install terraform 2. Set the proper variables Important Make sure you modify the value of the app_name, rg_name and rg_location variables. The app_name value is appended by azurewebsites.net and must be unique. Otherwise the script will fail that it cannot create the website. In the QuickStart folder setup, authentication is disabled. If you want that enabled, make sure you have create an Application in the Azure AD and have the client ID. This client id must be set as the value of the client_id variable in variables.tf. In the main.tf make sure you uncomment the authentication settings in the app-service. For more information see Configure Azure AD authentication - Azure App Service. If you want to set a custom domain for your documentation website with an SSL certificate you have to do some extra steps. You have to create a Key Vault and store the certificate there. Next step is to uncomment and set the values in variables.tf. You also have to uncomment the necessary steps in main.tf. All is indicated by comment-boxes. For more information see Add a TLS/SSL certificate in Azure App Service. Some extra information on SSL certificate, custom domain and Azure App Service can be found in the following paragraphs. If you are familiar with that or don't need it, go ahead and continue with Step 3. SSL Certificate To secure a website with a custom domain name and a certificate, you can find the steps to take in the article Add a TLS/SSL certificate in Azure App Service. That article also contains a description of ways to obtain a certificate and the requirements for a certificate. Usually you'll get a certificate from the customers IT department. If you want to start with a development certificate to test the process, you can create one yourself. You can do that in PowerShell with the script below. Replace: [YOUR DOMAIN] with the domain you would like to register, e.g. docs.somewhere.com [PASSWORD] with a password of the certificate. It's required for uploading a certificate in the Key Vault to have a password. You'll need this password in that step. [FILENAME] for the output file name of the certificate. You can even insert the path here where it should be store on your machine. You can store this script in a PowerShell script file (ps1 extension). $cert = New-SelfSignedCertificate -CertStoreLocation cert:\\currentuser\\my -Subject \"cn=[YOUR DOMAIN]\" -DnsName \"[YOUR DOMAIN]\" $pwd = ConvertTo-SecureString -String '[PASSWORD]' -Force -AsPlainText $path = 'cert:\\currentuser\\my\\' + $cert.thumbprint Export-PfxCertificate -cert $path -FilePath [FILENAME].pfx -Password $pwd The certificate needs to be stored in the common Key Vault. Go to Settings > Certificates in the left menu of the Key Vault and click Generate/Import. Provide these details: Method of Certificate Creation: Import Certificate name: e.g. ssl-certificate Upload Certificate File: select the file on disc for this. Password: this is the [PASSWORD] we reference earlier. Custom domain registration To use a custom domain a few things need to be done. The process in the Azure portal is described in the article Tutorial: Map an existing custom DNS name to Azure App Service. An important part is described under the header Get a domain verification ID. This ID needs to be registered with the DNS description as a TXT record. Important to know is that this Custom Domain Verification ID is the same for all web resources in the same Azure subscription. See this StackOverflow issue. This means that this ID needs to be registered only once for one Azure Subscription. And this enables (re)creation of an App Service with the custom domain though script. Add Get-permissions for Microsoft Azure App Service The Azure App Service needs to access the Key Vault to get the certificate. This is needed for the first run, but also when the certificate is renewed in the Key Vault. For this purpose the Azure App Service accesses the Key Vault with the App Service resource provided identity. This identity can be found with the service principal name abfa0a7c-a6b6-4736-8310-5855508787cd or Microsoft Azure App Service and is of type Application. This ID is the same for all Azure subscriptions. It needs to have Get-permissions on secrets and certificates. For more information see this article Import a certificate from Key Vault. Add the custom domain and SSL certificate to the App Service Once we have the SSL certificate and there is a complete DNS registration as described, we can uncomment the code in the Terraform script from the QuickStart folder to attach this to the App Service. In this script you need to reference the certificate in the common Key Vault and use it in the custom hostname binding. The custom hostname is assigned in the script as well. The settings ssl_state needs to be SniEnabled if you're using an SSL certificate. Now the creation of the authenticated website with a custom domain is automated. 3. Deploy Azure resources from your local machine Open up a command prompt. For the commands to be executed, you need to have a connection to your Azure subscription. This can be done using Azure Cli. Type this command: az login This will use the web browser to login to your account. You can check the connected subscription with this command: az account show If you have to change to another subscription, use this command where you replace [id] with the id of the subscription to select: az account set --subscription [id] Once this is done run this command to initialize: terraform init Now you can run the command to plan what the script will do. You run this command every time changes are made to the terraform scripts: terraform plan Inspect the result shown. If that is what you expect, apply these changes with this command: terraform apply When asked for approval, type \"yes\" and ENTER. You can also add the -auto-approve flag to the apply command. The deployment using Terraform is not included in the pipeline from the QuickStart folder as described in the next step, as that asks for more configuration. But of course that can always be added. 4. Deploy the website from a pipeline The best way to create the resources and deploy to it, is to do this automatically in a pipeline. For this purpose the .pipelines/documentation.yml pipeline is provided. This pipeline is built for an Azure DevOps environment. Create a pipeline and reference this YAML file. Important the QuickStart folder contains a web.config that is needed for deployment to IIS or Azure App Service. This enables the use of the json file for search requests. If you don't have this in place, the search of text will never return anything and result in 404's under the hood. You have to create a Service Connection in your DevOps environment to connect to the Azure Subscription you want to deploy to. Important set the variables AzureConnectionName to the name of the Service Connection and the AzureAppServiceName to the name you determined in the infrastructure/variables.tf. In the QuickStart folder the pipeline uses master as trigger, which means that any push being done to master triggers the pipeline. You will probably change this to another branch."
  },
  "general/about-docs/using-mermaid.html": {
    "href": "general/about-docs/using-mermaid.html",
    "title": "Using Mermaid | R3dux Documentation",
    "keywords": "Using Mermaid Mermaid can be used to generate all kinds of diagrams. Here are a few examples. Sample Sequence diagram ```mermaid sequenceDiagram Alice->>John: Hello John, how are you? John-->>Alice: Great! Alice-)John: See you later! ``` sequenceDiagram Alice->>John: Hello John, how are you? John-->>Alice: Great! Alice-)John: See you later! Sample Gantt diagram ```mermaid gantt title Example Gantt diagram dateFormat YYYY-MM-DD section Team 1 Research & requirements :done, a1, 2023-02-08, 2023-03-10 Review & documentation : after a1, 20d section Team 2 Implementation :crit, active, 2023-03-25 , 20d Testing :crit, 20d ``` gantt title Example Gantt diagram dateFormat YYYY-MM-DD section Team 1 Research & requirements :done, a1, 2023-02-08, 2023-03-10 Review & documentation : after a1, 20d section Team 2 Implementation :crit, active, 2023-03-25 , 20d Testing :crit, 20d Sample Class diagram ```mermaid --- title: Animal example --- classDiagram note \"From Duck till Zebra\" Animal <|-- Duck note for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\" Animal <|-- Fish Animal <|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ``` --- title: Animal example --- classDiagram note \"From Duck till Zebra\" Animal <|-- Duck note for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\" Animal <|-- Fish Animal <|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } Sample Entity Relationship diagram ```mermaid --- title: Order example --- erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ``` --- title: Order example --- erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses Sample Flowchart diagram ```mermaid flowchart TD A[Start] --> B{Is it?} B -->|Yes| C[OK] C --> D[Rethink] D --> B B ---->|No| E[End] ``` flowchart TD A[Start] --> B{Is it?} B -->|Yes| C[OK] C --> D[Rethink] D --> B B ---->|No| E[End]"
  },
  "general/advanced-topics/README.html": {
    "href": "general/advanced-topics/README.html",
    "title": "Advanced Topics | R3dux Documentation",
    "keywords": "Advanced Topics This section covers advanced topics related to R3dux, including immutability, type safety, error handling, performance optimization, and integration with other libraries. Use these resources to deepen your understanding of R3dux and explore advanced concepts and techniques for building robust and efficient applications. Page Description Immutable State Management In-depth discussion on immutability. Normalized State Managing normalized state in R3dux. Type Safety and Generics Using type safety and generics in R3dux. Error Handling and Debugging Techniques for error handling and debugging. Performance Optimization Tips and techniques for optimizing performance. Integration with Other Libraries How to integrate R3dux with other libraries."
  },
  "general/advanced-topics/error-handling-and-debugging.html": {
    "href": "general/advanced-topics/error-handling-and-debugging.html",
    "title": "Error Handling and Debugging | R3dux Documentation",
    "keywords": "Error Handling and Debugging"
  },
  "general/advanced-topics/immutable-state-management.html": {
    "href": "general/advanced-topics/immutable-state-management.html",
    "title": "Immutable State Management | R3dux Documentation",
    "keywords": "Immutable State Management Immutability is a core principle in modern state management, and it plays a crucial role in ensuring that your application remains predictable, easy to debug, and scalable. In R3dux, immutability is enforced across all state transformations, making it an essential concept to understand deeply. What is Immutability? Immutability means that once an object is created, it cannot be modified. Any change to an immutable object results in the creation of a new object rather than altering the existing one. In the context of state management, immutability ensures that state changes are explicit, traceable, and predictable. Key Characteristics of Immutability No Side Effects: Since immutable objects cannot be changed, they prevent unintended side effects, making your code more reliable and easier to reason about. State Integrity: Immutability guarantees that previous states remain unchanged, preserving the integrity of your state history, which is essential for debugging and time-travel debugging. Thread Safety: Immutable objects are inherently thread-safe, as they do not require locks or other synchronization mechanisms to protect shared state. What are the Benefits of Immutability? Immutability offers several advantages that can significantly enhance the quality and performance of your applications: 1. Increased Performance Although it may seem counterintuitive, immutability can lead to increased performance in many scenarios. Techniques like structural sharing allow immutable data structures to reuse parts of themselves, reducing the need to copy entire structures when changes occur. This results in efficient memory usage and faster state updates. 2. Simpler Programming Immutable data structures simplify programming because they eliminate a whole class of bugs related to unexpected changes in state. When data cannot change, reasoning about the flow of data and the effects of operations becomes more straightforward. This leads to cleaner, more maintainable code. 3. Easier Debugging With immutability, debugging becomes easier because you can rely on the fact that previous states remain unchanged. This stability allows you to examine the history of state changes without worrying about past states being altered, enabling powerful debugging techniques such as time-travel debugging. Immutability in Action: CounterState Example To illustrate how immutability works in practice, let's take a look at a simple example using CounterState. Example: Immutable Counter State Hereâ€™s how you would define and manage an immutable counter state: public record CounterState(int Value); public record CounterReducers : SliceReducers<CounterState> { public CounterReducers() { On<Increment>((state, action) => new CounterState(state.Value + action.Amount)); On<Decrement>((state, action) => new CounterState(state.Value - action.Amount)); On<Reset>(GetInitialState); On<SetValue>((_, action) => new CounterState(action.Value)); } public override CounterState GetInitialState() { return new CounterState(10); } } In this example: CounterState is defined as an immutable record, where each change results in a new instance. The reducers (On<Increment>, On<Decrement>, etc.) return new instances of CounterState instead of modifying the existing state. Example: Updating Counter State Immutably var newState = state with { Value = state.Value + 1 }; State Update: The with expression creates a new CounterState with an updated value, leaving the original state untouched. Why is Immutability Required by R3dux? Immutability is not just a best practice in R3dux; it is a fundamental requirement. Hereâ€™s why: 1. Ensures Predictability R3dux is designed around the principle that state should only change in predictable, controlled ways. Immutability enforces this by ensuring that every state change is a deliberate act that results in a new state object. This predictability is crucial for building reliable, bug-free applications. 2. Supports Advanced Debugging Techniques Immutability allows for powerful debugging tools, such as time-travel debugging, where you can move forward and backward through the state changes. This capability is only possible if previous states remain intact and unaltered. 3. Facilitates Undo/Redo Functionality Immutability simplifies the implementation of undo/redo functionality by preserving the history of state changes. Since past states are not modified, you can easily revert to a previous state or reapply changes without concern for unintended side effects. 4. Improves Application Performance Through structural sharing, immutability in R3dux is optimized to avoid the performance pitfalls often associated with copying large amounts of data. By reusing unchanged parts of the state, R3dux ensures that your application remains responsive even as the complexity of the state grows. 5. Enforces Best Practices By requiring immutability, R3dux enforces best practices in state management, guiding developers towards writing more maintainable, robust, and scalable code. This enforcement helps prevent a wide range of bugs that stem from unintended state mutations. Immutability in Complex Scenarios: TodoState Example For more complex state structures, like managing a collection of todo items, immutability is handled through normalized state management: public record TodoState : NormalizedState<Guid, TodoItem, TodoState> { // Selectors and other methods... public override TodoState SetOne(TodoItem entity) { return this with { ById = ById.SetItem(entity.Id, entity) }; } public override TodoState RemoveOne(Guid key) { return this with { ById = ById.Remove(key) }; } } In this more complex example: The state changes are still handled immutably, with each operation (e.g., SetOne, RemoveOne) returning a new state. The with keyword is used to create a new state based on the current state, with only the necessary modifications applied. Conclusion: Immutability is Essential Immutability is a cornerstone of reliable, predictable state management in R3dux. By enforcing immutability, R3dux ensures that your applicationâ€™s state transitions are clear, traceable, and free from unintended side effects. This not only makes your application easier to develop and debug but also lays the foundation for scalable, maintainable code that can grow with your applicationâ€™s needs. Embracing immutability in your R3dux applications will lead to better performance, simpler code, and more robust applications that are easier to maintain and extend."
  },
  "general/advanced-topics/integration-with-other-libraries.html": {
    "href": "general/advanced-topics/integration-with-other-libraries.html",
    "title": "Integration with Other Libraries | R3dux Documentation",
    "keywords": "Integration with Other Libraries"
  },
  "general/advanced-topics/normalized-state.html": {
    "href": "general/advanced-topics/normalized-state.html",
    "title": "Normalized State | R3dux Documentation",
    "keywords": "Normalized State Managing complex state structures efficiently is a common challenge in modern applications. R3dux addresses this challenge with NormalizedStateâ€”a powerful abstraction that simplifies the handling of collections of entities. By normalizing your state, you ensure that your applicationâ€™s data is easy to manage, query, and update, all while maintaining the benefits of immutability. What is NormalizedState? NormalizedState is a specialized record in R3dux designed to manage collections of entities in a normalized form. It organizes entities in an immutable dictionary keyed by a unique identifier, streamlining operations such as querying, updating, and deleting entities. This structure not only prevents data duplication but also makes relationships between entities more straightforward to handle. Key Characteristics Normalization: Entities are stored in an ImmutableDictionary, indexed by a unique key (e.g., Guid, int). This eliminates redundancy and simplifies the management of related entities. Immutability: All operations on the state return a new instance, ensuring that state changes are predictable, traceable, and free from side effects. Comprehensive API: NormalizedState provides a rich set of methods for common operations, making it easier to manipulate collections of entities in a consistent and predictable way. Defining a Normalized State To define a normalized state, extend the NormalizedState<TKey, TEntity, TState> record. This approach centralizes the management of your entities and provides built-in methods for common tasks. Example: Defining a Todo State Consider a todo application where each todo item has a unique identifier. Here's how you would define a normalized state for managing todos: public record TodoState : NormalizedState<Guid, TodoItem, TodoState> { // Selectors for retrieving specific subsets of todos public ImmutableList<TodoItem> SelectCompletedTodos() { return SelectImmutableList(todo => todo.IsCompleted); } public int SelectCompletedTodosCount() { return SelectCompletedTodos().Count; } public bool SelectHasCompletedTodos() { return !SelectCompletedTodos().IsEmpty; } public ImmutableList<TodoItem> SelectActiveTodos() { return SelectImmutableList(todo => !todo.IsCompleted); } public int SelectActiveTodosCount() { return SelectActiveTodos().Count(); } public bool SelectHasActiveTodos() { return !SelectActiveTodos().IsEmpty; } } In this example: TodoState inherits from NormalizedState<Guid, TodoItem, TodoState>, managing a collection of TodoItem entities. Selectors are defined to encapsulate logic for querying the state, such as retrieving completed or active todos. Core Methods of NormalizedState The NormalizedState record provides a comprehensive API for managing collections of entities. These methods ensure that all state changes are performed immutably and consistently. Entity Management Methods Hereâ€™s an overview of the key methods available in NormalizedState: Create: Initializes a new state with a collection of entities. public static TState Create(ImmutableList<TEntity> entities) Example: var initialState = TodoState.Create(initialTodos); AddOne: Adds a single entity to the state. public TState AddOne(TEntity entity) Example: var newState = state.AddOne(new TodoItem(Guid.NewGuid(), \"New Task\")); AddMany: Adds multiple entities to the state. public TState AddMany(IEnumerable<TEntity> entities) Example: var newState = state.AddMany(newListOfTodos); SetOne: Replaces or adds a single entity. public TState SetOne(TEntity entity) Example: var updatedState = state.SetOne(updatedTodo); SetMany: Replaces or adds multiple entities. public TState SetMany(IEnumerable<TEntity> entities) Example: var updatedState = state.SetMany(updatedTodos); RemoveOne: Removes an entity by its key. public TState RemoveOne(TKey key) Example: var newState = state.RemoveOne(todoId); RemoveMany: Removes multiple entities by their keys. public TState RemoveMany(IEnumerable<TKey> keys) Example: var newState = state.RemoveMany(todoIds); UpdateOne: Updates a single entity using an action or function. public TState UpdateOne(TKey key, Action<TEntity> update) public TState UpdateOne(TKey key, Func<TEntity, TEntity> update) Example: var updatedState = state.UpdateOne(todoId, todo => todo.MarkAsCompleted()); UpdateMany: Updates multiple entities using an action or function. public TState UpdateMany(IEnumerable<TKey> keys, Action<TEntity> update) public TState UpdateMany(IEnumerable<TKey> keys, Func<TEntity, TEntity> update) Example: var updatedState = state.UpdateMany(todoIds, todo => todo.MarkAsCompleted()); UpsertOne: Updates or inserts a single entity. public TState UpsertOne(TEntity entity) Example: var newState = state.UpsertOne(newTodoItem); UpsertMany: Updates or inserts multiple entities. public TState UpsertMany(IEnumerable<TEntity> entities) Example: var newState = state.UpsertMany(todoItems); MapOne: Transforms a single entity by applying a function. public TState MapOne(TKey key, Func<TEntity, TEntity> map) Example: var mappedState = state.MapOne(todoId, todo => todo.WithPriority(\"High\")); Map: Transforms all entities in the state. public TState Map(Func<TEntity, TEntity> map) Example: var mappedState = state.Map(todo => todo.WithCategory(\"Work\")); Example: Adding, Updating, and Removing Entities // Adding a new todo item var newState = state.AddOne(new TodoItem(Guid.NewGuid(), \"New Task\")); // Updating an existing todo item newState = newState.UpdateOne(todoId, todo => todo.MarkAsCompleted()); // Removing a todo item newState = newState.RemoveOne(todoId); Advanced Operations with NormalizedState Merging Entities When you need to merge a set of entities into the state, you can use the Merge method. This method allows for different merge strategies, such as overwriting existing entities or failing if duplicates are found. var mergedState = state.Merge(newEntitiesDictionary, MergeStrategy.Overwrite); MergeStrategy.FailIfDuplicate: Ensures that no duplicates are merged into the state. MergeStrategy.Overwrite: Overwrites any existing entities with the new ones. Querying Entities Entities stored in a NormalizedState are indexed by their keys, making it easy to query them efficiently. You can retrieve an entity directly by its key using the indexer. var todo = state[todoId]; Filtering with Selectors Selectors allow you to define reusable queries that filter or transform the state. This keeps your components clean and focused on rendering UI rather than managing data. public ImmutableList<TodoItem> SelectCompletedTodos() { return SelectImmutableList(todo => todo.IsCompleted); } Understanding the Serialized State When the state is serialized (for example, for debugging, logging, or persistence purposes), NormalizedState organizes your data in a structured way that highlights the benefits of normalization. Hereâ€™s how the state is typically represented in JSON: { \"type\": \"AppStore.Todos.TodoState, AppStore, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\", \"value\": { \"by-id\": { \"00000000-0000-0000-0000-111111111111\": { \"id\": \"00000000-0000-0000-0000-111111111111\", \"title\": \"Learn Blazor\", \"is-completed\": true }, \"00000000-0000-0000-0000-222222222222\": { \"id\": \"00000000-0000-0000-0000-222222222222\", \"title\": \"Learn Redux\", \"is-completed\": false }, \"00000000-0000-0000-0000-333333333333\": { \"id\": \"00000000-0000-0000-0000-333333333333\", \"title\": \"Learn Reactive Programming\", \"is-completed\": false }, \"00000000-0000-0000-0000-444444444444\": { \"id\": \"00000000-0000-0000-0000-444444444444\", \"title\": \"Create a Todo App\", \"is-completed\": true }, \"00000000-0000-0000-0000-555555555555\": { \"id\": \"00000000-0000-0000-0000-555555555555\", \"title\": \"Publish a NuGet package\", \"is-completed\": false } }, \"all-ids\": [ \"00000000-0000-0000-0000-111111111111\", \"00000000-0000-0000-0000-222222222222\", \"00000000-0000-0000-0000-333333333333\", \"00000000-0000-0000-0000-444444444444\", \"00000000-0000-0000-0000-555555555555\" ] } } Breakdown of the Serialized Structure type: This field indicates the fully qualified name of the state type, including the assembly information. It tells the system how to deserialize this state back into its original type. by-id: This dictionary holds the entities indexed by their unique keys. Each key corresponds to an entity's ID, and the value is the entity itself, represented as a JSON object. all-ids: This array lists all the keys (IDs) of the entities stored in the state. It preserves the order of the entities as they were added, which can be useful for displaying items in a particular order. Advantages of the Serialized Format Efficiency: By storing entities in a dictionary, operations like lookups, updates, and deletions are very efficient. Clarity: The separation between the by-id dictionary and the all-ids list provides a clear distinction between the entities themselves and their ordering, making it easier to understand and manipulate the state. Consistency: When rehydrating (deserializing) the state, the structure ensures that all entities are restored accurately, maintaining the relationships and order as intended. This structured approach not only makes the state more manageable within your application but also ensures that any serialized data is robust, easy to inspect, and straightforward to restore. Best Practices for Using NormalizedState Embrace Immutability: Always use the provided methods to modify the state. This ensures that all changes are made immutably, which is crucial for maintaining predictable state transitions. Utilize Selectors: Encapsulate querying logic within selectors. This not only simplifies your components but also promotes reuse across your application. Carefully Choose Merge Strategies: When merging entities, choose the appropriate strategy to avoid unintentional overwrites or errors due to duplicates. Encapsulate Common Operations: Define common operations (such as adding, updating, or removing entities) within your state class. This promotes consistency and reduces the risk of errors."
  },
  "general/advanced-topics/performance-optimization.html": {
    "href": "general/advanced-topics/performance-optimization.html",
    "title": "Performance Optimization | R3dux Documentation",
    "keywords": "Performance Optimization"
  },
  "general/advanced-topics/type-safety-and-generics.html": {
    "href": "general/advanced-topics/type-safety-and-generics.html",
    "title": "Type Safety and Generics | R3dux Documentation",
    "keywords": "Type Safety and Generics"
  },
  "general/api-reference/README.html": {
    "href": "general/api-reference/README.html",
    "title": "API Reference | R3dux Documentation",
    "keywords": "API Reference API Reference contains detailed information about the classes, interfaces, and utility functions provided by R3dux. Use this section to explore the core concepts and features of the library and learn how to use them effectively in your applications. Page Description IAction Interface Detailed reference of the IAction interface. SliceReducers Documentation for the SliceReducers class. Effect Base Class Documentation for the Effect base class. Store Class Detailed reference for the Store class. Custom Operators Documentation for custom operators provided by R3dux. Utility Functions List and explain various utility functions."
  },
  "general/api-reference/custom-operators.html": {
    "href": "general/api-reference/custom-operators.html",
    "title": "Custom Operators | R3dux Documentation",
    "keywords": "Custom Operators"
  },
  "general/api-reference/effect-base.html": {
    "href": "general/api-reference/effect-base.html",
    "title": "Effect Base Class | R3dux Documentation",
    "keywords": "Effect Base Class"
  },
  "general/api-reference/i-action.html": {
    "href": "general/api-reference/i-action.html",
    "title": "IAction Interface | R3dux Documentation",
    "keywords": "IAction Interface"
  },
  "general/api-reference/slice-reducers.html": {
    "href": "general/api-reference/slice-reducers.html",
    "title": "SliceReducers | R3dux Documentation",
    "keywords": "SliceReducers"
  },
  "general/api-reference/store.html": {
    "href": "general/api-reference/store.html",
    "title": "Store Class | R3dux Documentation",
    "keywords": "Store Class"
  },
  "general/api-reference/utility-functions.html": {
    "href": "general/api-reference/utility-functions.html",
    "title": "Utility Functions | R3dux Documentation",
    "keywords": "Utility Functions"
  },
  "general/architecture-decisions/README.html": {
    "href": "general/architecture-decisions/README.html",
    "title": "Architecture Decisions | R3dux Documentation",
    "keywords": "Architecture Decisions You can include ADR's in this folder. Tip Use template documents like the high level design recipe and such from the CSE Playbook - Design Reviews."
  },
  "general/architecture-decisions/decision-log.html": {
    "href": "general/architecture-decisions/decision-log.html",
    "title": "Decision Log | R3dux Documentation",
    "keywords": "Decision Log This document is used to track key decisions that are made during the course of the project. This can be used at a later stage to understand why decisions were made and by whom. Decision Date Alternatives Considered Reasoning Detailed doc Made By Work Required We will continue providing valuable documentation during the complete course of this project 19/08/2021 No documentation at all, some documentation We want to describe how the solution is constructed, but also why. And we want to enable every developer to have a quick(er) onboarding experience and understanding of the sytem, (sub-)systems, frameworks and procedures that can be used. Documentation guidelines All"
  },
  "general/best-practices/README.html": {
    "href": "general/best-practices/README.html",
    "title": "Best Practices | R3dux Documentation",
    "keywords": "Best Practices By following these best practices, you can ensure that your R3dux application is well-organized, maintainable, and performant. These guidelines are designed to help you make the most of the library and build robust, scalable applications with ease. Page Description Structuring Your Application Best practices for organizing your code. Testing Your R3dux Code Guidelines for writing tests for your R3dux code. Handling Large State Trees Techniques for managing large state trees. Debugging and Logging Best practices for debugging and logging."
  },
  "general/best-practices/debugging-and-logging.html": {
    "href": "general/best-practices/debugging-and-logging.html",
    "title": "Debugging and Logging | R3dux Documentation",
    "keywords": "Debugging and Logging"
  },
  "general/best-practices/handling-large-state-trees.html": {
    "href": "general/best-practices/handling-large-state-trees.html",
    "title": "Handling Large State Trees | R3dux Documentation",
    "keywords": "Handling Large State Trees"
  },
  "general/best-practices/structuring-your-application.html": {
    "href": "general/best-practices/structuring-your-application.html",
    "title": "Structuring Your Application | R3dux Documentation",
    "keywords": "Structuring Your Application"
  },
  "general/best-practices/testing-your-r3dux-code.html": {
    "href": "general/best-practices/testing-your-r3dux-code.html",
    "title": "Testing Your R3dux Code | R3dux Documentation",
    "keywords": "Testing Your R3dux Code"
  },
  "general/changelog/README.html": {
    "href": "general/changelog/README.html",
    "title": "Changelog | R3dux Documentation",
    "keywords": "Changelog This document provides a summary of the changes in each version of R3dux. Page Description Version History History of all the releases. Release Notes Notes for each release."
  },
  "general/changelog/release-notes.html": {
    "href": "general/changelog/release-notes.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/changelog/version-history.html": {
    "href": "general/changelog/version-history.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/community-and-contribution/README.html": {
    "href": "general/community-and-contribution/README.html",
    "title": "Community and Contribution | R3dux Documentation",
    "keywords": "Community and Contribution Welcome to the R3dux community! We are excited to have you here and look forward to your contributions. Whether you are a developer, designer, or user, there are many ways to get involved and help improve R3dux. Page Description Contributing to R3dux How to contribute to the project. Code of Conduct Code of conduct for contributors. Reporting Issues Guidelines for reporting issues. Feature Requests How to request new features."
  },
  "general/community-and-contribution/code-of-conduct.html": {
    "href": "general/community-and-contribution/code-of-conduct.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/community-and-contribution/contributing.html": {
    "href": "general/community-and-contribution/contributing.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/community-and-contribution/feature-requests.html": {
    "href": "general/community-and-contribution/feature-requests.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/community-and-contribution/reporting-issues.html": {
    "href": "general/community-and-contribution/reporting-issues.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/core-concepts/README.html": {
    "href": "general/core-concepts/README.html",
    "title": "Core concepts | R3dux Documentation",
    "keywords": "Core concepts In this section, we will cover the core concepts of R3dux, including state management, actions, reducers, effects, and selectors. Understanding these concepts is essential for building applications with R3dux. Page Description State Management Explain the concept of a global state. Actions Describe how to define and use actions. Reducers Explain the role of reducers in state management. Effects Discuss handling side effects with effects. Selectors Describe how to use selectors for derived state."
  },
  "general/core-concepts/actions.html": {
    "href": "general/core-concepts/actions.html",
    "title": "Actions | R3dux Documentation",
    "keywords": "Actions Actions in R3dux are a fundamental part of the state management process. They serve as the only means by which the global state can be modified, ensuring that all state changes are predictable, traceable, and consistent across the application. What are Actions? Actions are simple objects that describe a change that should occur in the state. An action typically contains a type that indicates the nature of the action, and optionally, some data (payload) that provides additional information needed to perform the state update. Key Characteristics of Actions Intent Declaration: Actions declare the intent to change the state. They do not execute the change themselves but serve as a signal to the store that a change should be made. Plain Objects: Actions in R3dux are typically simple objects or records that implement the IAction interface. This simplicity ensures that actions are easy to create, dispatch, and test. Immutable: Actions should be immutable, meaning once they are created, their properties should not be modified. This immutability aligns with the overall philosophy of predictable and traceable state management. Defining Actions Defining actions in R3dux is straightforward. You simply create a class or record that implements the IAction interface. Hereâ€™s an example: public record Increment(int Amount = 1) : IAction; public record Decrement(int Amount = 1) : IAction; Action Types Each action should have a distinct type that identifies what kind of state change it represents. In C#, when using records or classes for actions, the class or record name typically serves as the action type implicitly. Example: public record SetUserName(string UserName) : IAction; In this example: The SetUserName action contains a single property, UserName, which is the payload needed to update the state. The action implicitly has a type, which is the name of the record (SetUserName). Dispatching Actions Once actions are defined, they are dispatched to the store to initiate a state change. Dispatching an action involves passing it to the store, which then uses reducers to update the state accordingly. Example of Dispatching an Action Consider a Blazor component that needs to update the user's name in the global state: @code { private void UpdateUserName() { Dispatch(new SetUserName(\"John Doe\")); } } In this example: The SetUserName action is dispatched with the payload \"John Doe\". The store processes this action, and the state is updated with the new user name. Handling Actions in Reducers Actions by themselves do not modify the state. Instead, they are handled by reducers, which are responsible for interpreting the action and determining how the state should change in response. Example of Handling Actions in Reducers public class UserReducers : SliceReducers<UserState> { public UserReducers() { On<SetUserName>((state, action) => state with { UserName = action.UserName }); } public override UserState GetInitialState() { return new UserState { UserName = \"Anonymous\" }; } } In this reducer: The On<SetUserName> method maps the SetUserName action to a state change that updates the UserName property. The new state is created immutably using the with keyword. Action Payloads Actions often carry additional data necessary to perform a state update. This data is known as the action's payload. The payload is passed to reducers along with the current state, allowing the reducer to create a new state based on the information provided. Example of an Action with Payload public record AddProduct(string ProductName, decimal Price) : IAction; In this example: The AddProduct action contains two pieces of information: ProductName and Price. When this action is dispatched, the reducer will use this data to update the state, typically by adding a new product to a list in the state. Actions and Asynchronous Operations While actions themselves are typically synchronous, they can be dispatched from asynchronous operations. This is often handled through Effects in R3dux, where actions are dispatched based on the result of an asynchronous operation such as an API call. Example: public class LoadProductsEffect : Effect { public override Observable<IAction> Handle( Observable<IAction> actions, Observable<IRootState> rootState) { return actions .OfType<LoadProducts>() .InvokeService( async () => await productService.GetProductsAsync(), products => new LoadProductsSuccess(products), ex => new LoadProductsFailure(ex)); } } In this example: The LoadProducts action is dispatched to trigger the loading of products. Depending on the outcome of the service call, either LoadProductsSuccess or LoadProductsFailure is dispatched. Best Practices for Actions Keep Actions Simple: Actions should be simple and focused. They should contain only the information necessary to describe the state change. Use Meaningful Names: Name your actions clearly to reflect their purpose. This makes your code more readable and easier to maintain. Leverage Immutability: Ensure that actions are immutable to maintain consistency and predictability in state management. Document Your Actions: Clearly document what each action does, especially in large applications where many actions may exist."
  },
  "general/core-concepts/effects.html": {
    "href": "general/core-concepts/effects.html",
    "title": "Effects | R3dux Documentation",
    "keywords": "Effects In R3dux, effects are a powerful tool for handling side effectsâ€”operations that interact with the outside world or involve asynchronous logic. Effects listen to the stream of actions dispatched to the store and can dispatch new actions based on the outcome of those operations, such as API calls, logging, or timers. What are Effects? Effects are responsible for managing side effects in your application. Unlike reducers, which handle pure state transformations, effects are used to perform operations that have side effects, such as: Making asynchronous API calls. Dispatching notifications. Handling time-based events (like timers). Interacting with services outside of your state management logic. Key Characteristics of Effects Asynchronous Operations: Effects can handle asynchronous operations such as API calls, allowing your application to interact with external services or data sources. Dispatching New Actions: Based on the outcome of the side effect, effects can dispatch new actions to update the state. Separation of Concerns: Effects keep side effects separate from reducers, ensuring that state transformations remain pure and predictable. Defining Effects In R3dux, you define an effect by extending the Effect class and overriding the Handle method. The Handle method takes two parameters: Observable<IAction> actions: The stream of actions dispatched to the store. Observable<IRootState> rootState: The observable stream of the current state. Example: Loading Movies with an API Call Hereâ€™s an example of an effect that handles loading movies from an external API: public class LoadMoviesEffect : Effect { private readonly IMoviesService _moviesService; public LoadMoviesEffect(IMoviesService moviesService) { _moviesService = moviesService; } public override Observable<IAction> Handle( Observable<IAction> actions, Observable<IRootState> rootState) { return actions .OfType<LoadMovies>() .LogMessage(\"Loading movies...\") .WithSliceState<MoviesState, LoadMovies>(rootState) .InvokeService( pair => _moviesService.GetMoviesAsync(pair.State.Pagination.CurrentPage, 5), response => new LoadMoviesSuccess(response.Movies, response.TotalItems), ex => new LoadMoviesFailure(ex)) .LogMessage(\"Movies loaded.\"); } } In this example: The LoadMoviesEffect listens for the LoadMovies action. It logs the action, retrieves the current state slice, and invokes the GetMoviesAsync method from IMoviesService. Based on the API response, it dispatches either LoadMoviesSuccess or LoadMoviesFailure actions. Example: Displaying Notifications After a Successful Load This example demonstrates how to use an effect to display a success notification after movies are successfully loaded: public class LoadMoviesSuccessEffect : Effect { private readonly ISnackbar _snackbar; public LoadMoviesSuccessEffect(ISnackbar snackbar) { _snackbar = snackbar; } public override Observable<IAction> Handle( Observable<IAction> actions, Observable<IRootState> rootState) { return actions .OfType<IAction, LoadMoviesSuccess>() .Select(GetSnackBarMessage) .Do(message => _snackbar.Add(message, Severity.Success)) .Select(message => { var notification = new SuccessNotification(message); return (IAction)new AddNotification(notification); }); } private static string GetSnackBarMessage(LoadMoviesSuccess action) { return $\"Loaded {action.Movies.Length} movies from the server.\"; } } In this example: The LoadMoviesSuccessEffect listens for the LoadMoviesSuccess action. It generates a success message and displays it using the ISnackbar service. After displaying the notification, it dispatches a new AddNotification action. Example: Handling Timers Effects are also useful for handling time-based operations, such as starting and stopping timers. Here's an example of an effect that handles a timer: public class StartTimerEffect : Effect { public override Observable<IAction> Handle( Observable<IAction> actions, Observable<IRootState> rootState) { return actions .OfType<StartTimer>() .SwitchSelect(_ => Observable .Interval(TimeSpan.FromSeconds(1), TimeProvider) .Select(_ => new Tick()) .TakeUntil(actions.OfType<StopTimer>()) .Cast<Tick, IAction>()); } } In this example: The StartTimerEffect listens for the StartTimer action. It starts a timer that dispatches a Tick action every second. The timer stops when a StopTimer action is dispatched. Custom Operators in Effects R3dux provides several custom operators to simplify common patterns in effects, such as filtering actions, invoking services, and handling errors. Key Operators OfType: Filters actions of a specific type. WithSliceState: Combines actions with the corresponding slice of the state. InvokeService: Handles calling external services and dispatching success or error actions based on the outcome. Example: Using Custom Operators public override Observable<IAction> Handle( Observable<IAction> actions, Observable<IRootState> rootState) { return actions .OfType<LoadMovies>() .WithSliceState<MoviesState, LoadMovies>(rootState) .InvokeService( pair => _moviesService.GetMoviesAsync(pair.State.Pagination.CurrentPage, 5), response => new LoadMoviesSuccess(response.Movies, response.TotalItems), ex => new LoadMoviesFailure(ex)); } This code demonstrates how custom operators streamline the process of handling actions, accessing state, and performing service calls. Best Practices for Writing Effects Keep Effects Focused: Each effect should handle a specific side effect, such as an API call or a timer. This makes effects easier to manage and test. Use Custom Operators: Leverage R3duxâ€™s custom operators to simplify your effect logic and make it more readable. Handle Errors Gracefully: Always handle potential errors in your effects by dispatching appropriate failure actions. Avoid Side Effects in Reducers: Use effects, not reducers, for handling side effects. Reducers should remain pure and only manage state transformations."
  },
  "general/core-concepts/reducers.html": {
    "href": "general/core-concepts/reducers.html",
    "title": "Reducers | R3dux Documentation",
    "keywords": "Reducers Reducers are a core concept in R3dux's state management system. They are pure functions that take the current state and an action, and return a new state. Reducers are responsible for determining how the global state should change in response to a given action. What are Reducers? Reducers in R3dux are pure functions that dictate how the state of your application should change in response to actions. A reducer takes the current state and an action as inputs and returns a new state as output. This approach ensures that state transitions are predictable and traceable. Key Characteristics of Reducers Pure Functions: Reducers are pure functions, meaning they always return the same output for the same input and have no side effects. They do not modify the existing state but instead return a new state object. Immutability: Reducers enforce immutability by returning a new state object rather than mutating the existing state. This immutability is crucial for ensuring predictable state changes and making state management easier to debug. Centralized State Management: By centralizing state changes in reducers, you can ensure that all state transformations are handled in a controlled and predictable manner. Defining Reducers In R3dux, reducers are defined by extending the SliceReducers<TState> class, where TState represents the type of the state slice that the reducer manages. Within a reducer, you map actions to the state changes they should produce. Example of a Simple Reducer public class CounterReducers : SliceReducers<int> { public CounterReducers() { On<Increment>((state, _) => state + 1); On<Decrement>((state, _) => state - 1); } public override int GetInitialState() { return 0; } } In this example: The CounterReducers class manages a piece of state representing a simple integer counter. The On<Increment> method maps the Increment action to a state change that increases the counter by one. The On<Decrement> method decreases the counter by one when the Decrement action is dispatched. The GetInitialState method defines the initial state of the counter as 0. Handling Actions with Reducers Reducers use the On<TAction> method to specify how the state should change in response to a specific action. The On method takes two parameters: The type of action that the reducer handles. A function that defines how the state should change in response to the action. Example of Handling Actions public class UserReducers : SliceReducers<UserState> { public UserReducers() { On<SetUserName>((state, action) => state with { UserName = action.UserName }); On<SetUserAge>((state, action) => state with { Age = action.Age }); } public override UserState GetInitialState() { return new UserState { UserName = \"Anonymous\", Age = 0 }; } } In this example: The SetUserName action updates the UserName property of the state. The SetUserAge action updates the Age property of the state. The state with { ... } syntax ensures that the state is updated immutably. State Composition in R3dux In R3dux, the global state is automatically composed from the individual slice states managed by each reducer. This means that you don't need to manually combine reducers; instead, R3dux handles this composition behind the scenes. Example: Root State Composition Each slice reducer manages its own piece of the global state. For example, a UserReducers might manage the UserState, while a CounterReducers manages the CounterState. R3dux automatically combines these slices into the root state. public class RootState : IRootState { // RootState is automatically composed by R3dux from the individual slice states. } When you register reducers in R3dux, they automatically contribute to the overall application state, which R3dux manages as a RootState object. Refactoring Reducers with Extracted Methods As your application grows, your reducers may become more complex. To improve maintainability, you can refactor reducers by extracting logic into separate methods. Refactored Reducer Example public record TodoReducers : SliceReducers<TodoState> { public TodoReducers() { On<CreateTodo>(ReduceCreateTodo); On<ToggleTodo>(ReduceToggleTodo); On<DeleteTodo>(ReduceDeleteTodo); } public override TodoState GetInitialState() { return TodoState.Create(new[] { new TodoItem(SampleIds.Id1, \"Learn Blazor\", true), new TodoItem(SampleIds.Id2, \"Learn Redux\"), new TodoItem(SampleIds.Id3, \"Learn Reactive Programming\"), new TodoItem(SampleIds.Id4, \"Create a Todo App\", true), new TodoItem(SampleIds.Id5, \"Publish a NuGet package\") }); } private static TodoState ReduceCreateTodo(TodoState state, CreateTodo action) { return state.SetOne(new TodoItem(action.Payload.Title)); } private static TodoState ReduceToggleTodo(TodoState state, ToggleTodo action) { return state.UpdateOne(action.Payload.Id, todo => todo.IsCompleted = !todo.IsCompleted); } private static TodoState ReduceDeleteTodo(TodoState state, DeleteTodo action) { return state.RemoveOne(action.Payload.Id); } } In this example: The reducer methods (ReduceCreateTodo, ReduceToggleTodo, ReduceDeleteTodo) are extracted from the main reducer class, making the class more readable and easier to maintain. Each method is focused on a specific action, further enhancing the clarity and testability of the code. Initializing State Each reducer defines an initial state using the GetInitialState method. This method is called when the store is first created and sets up the default state for the application or the slice managed by the reducer. Example of Initializing State public override int GetInitialState() { return 10; // Sets the initial counter value to 10 } The GetInitialState method provides a default value for the state, ensuring that the application has a well-defined starting point. Best Practices for Writing Reducers Keep Reducers Pure: Reducers should not have side effects. Avoid making API calls or dispatching other actions from within a reducer. Use Immutability: Always return a new state object rather than mutating the existing state. Decompose State: Break down the state into smaller, manageable slices, each handled by its own reducer. Handle Actions Explicitly: Each reducer should explicitly handle specific actions. This makes the state transitions clear and predictable. Use Default States: Ensure that GetInitialState provides a meaningful default state for each slice of your application."
  },
  "general/core-concepts/selectors.html": {
    "href": "general/core-concepts/selectors.html",
    "title": "Selectors | R3dux Documentation",
    "keywords": "Selectors Selectors in R3dux are functions that allow you to extract and compute derived data from the global state. They encapsulate the logic for retrieving specific pieces of data and can be used to optimize performance by minimizing unnecessary recalculations. What are Selectors? Selectors are specialized functions designed to query and derive specific data from the state. They help you avoid duplicating logic across components and can improve performance by memoizing computed values, ensuring that they are only recalculated when necessary. Key Characteristics of Selectors Encapsulation: Selectors encapsulate the logic for selecting data from the state, making your components simpler and more focused. Reusability: Since selectors are functions, they can be reused across different parts of your application. Memoization: Selectors can be memoized to prevent unnecessary recalculations, which can significantly improve performance in large applications. Basic Selectors Selectors can be defined as methods within your state classes. These methods are responsible for querying the state and returning the relevant data. Example: Basic Selectors Hereâ€™s an example of a MoviesState record with basic selectors: public record MoviesState { public required ImmutableDictionary<int, Movie> Movies { get; init; } public required bool IsLoading { get; init; } public required string? ErrorMessage { get; init; } public required Pagination Pagination { get; init; } // Selectors // ========== // Selectors are defined as methods that encapsulate the logic of selecting data from the state. // Each method should begin with the word \"Select\". public int SelectMovieCount() { return Movies.Count; } public Movie? SelectMovieById(int id) { return Movies.GetValueOrDefault(id); } public ImmutableDictionary<int, Movie> SelectMoviesByYear() { return Movies .OrderByDescending(pair => pair.Value.Year) .ToImmutableDictionary(); } } In this example: The SelectMovieCount selector returns the total number of movies. The SelectMovieById selector retrieves a movie by its ID. The SelectMoviesByYear selector returns the movies sorted by their release year in descending order. Advanced Selectors As your application grows, you might need more advanced selectors that can handle complex queries or derived data. R3dux allows you to create memoized selectors that cache their results and recalculate only when the relevant parts of the state have changed. Example: Advanced Selectors with Memoization Hereâ€™s an example of a ProductState record that uses memoized selectors: public record ProductState : NormalizedState<Guid, Product, ProductState> { private readonly Func<ProductState, ImmutableList<Product>> _selectElectronics; private readonly Func<ProductState, ImmutableList<Product>> _selectClothing; private readonly Func<ProductState, decimal> _selectTotalPriceOfElectronics; private readonly Func<ProductState, decimal> _selectTotalPriceOfClothing; public ProductState() { _selectElectronics = MemoizedSelector.Create<ProductState, ImmutableList<Product>>( state => state.SelectImmutableList(product => product.Category == \"Electronics\"), state => state.ById); _selectClothing = MemoizedSelector.Create<ProductState, ImmutableList<Product>>( state => state.SelectImmutableList(product => product.Category == \"Clothing\"), state => state.ById); _selectTotalPriceOfElectronics = MemoizedSelector.Compose( _selectElectronics, products => products.Sum(product => product.Price), state => state.ById); _selectTotalPriceOfClothing = MemoizedSelector.Compose( _selectClothing, products => products.Sum(product => product.Price), state => state.ById); } // Memoized Selectors public ImmutableList<Product> SelectElectronics() { return _selectElectronics(this); } public ImmutableList<Product> SelectClothing() { return _selectClothing(this); } public decimal SelectTotalPriceOfElectronics() { return _selectTotalPriceOfElectronics(this); } public decimal SelectTotalPriceOfClothing() { return _selectTotalPriceOfClothing(this); } } In this example: Memoized Selectors: The selectors are memoized using the MemoizedSelector.Create and MemoizedSelector.Compose methods to avoid unnecessary recomputation. Advanced Queries: The SelectElectronics and SelectClothing selectors return lists of products filtered by category. Derived Data: The SelectTotalPriceOfElectronics and SelectTotalPriceOfClothing selectors compute the total price of products in each category, leveraging memoization to enhance performance. Using Selectors in Blazor Components A best practice when using selectors in Blazor components is to create properties that use the selectors, keeping the component's markup separate from its logic. This approach makes your components more maintainable and easier to read. Example: Using Selectors in a Blazor Component Hereâ€™s an example of a Blazor component that uses selectors to manage a Todo list: @page \"/todo\" @inherits R3duxComponent<TodoState> <PageTitle>R3dux - Todo List</PageTitle> <MudGrid> <MudItem xs=\"12\"> <MudStack> <MudText Typo=\"Typo.subtitle1\">Example</MudText> <MudText Typo=\"Typo.h3\">Todo List</MudText> <MudText Typo=\"Typo.body1\"> Manage your todos effectively with R3dux, featuring functionality to add, toggle, and remove todo items. </MudText> </MudStack> </MudItem> <MudItem xs=\"12\" lg=\"6\"> <MudStack> <MudBadge Content=\"@ActiveTodosCount\" Color=\"Color.Primary\"> <MudText Typo=\"Typo.h5\">Active Todos</MudText> </MudBadge> <MudPaper> @if (!HasActiveTodos) { <MudText Typo=\"Typo.h6\" Class=\"ma-4\"> No active todos - add a new todo item to get started! </MudText> } <MudList T=\"TodoItem\"> @foreach (var todo in ActiveTodos) { <MudListItem @key=\"todo.Id\"> <MudStack Row Justify=\"Justify.SpaceBetween\" AlignItems=\"AlignItems.Center\"> <MudIconButton Icon=\"@Icons.Material.Filled.CheckBoxOutlineBlank\" OnClick=\"() => ToggleTodoItem(todo.Id)\"/> <MudText>@todo.Title</MudText> <MudSpacer/> <MudButton Variant=\"Variant.Outlined\" Color=\"Color.Error\" OnClick=\"() => DeleteTodoItem(todo.Id)\">Delete</MudButton> </MudStack> </MudListItem> } </MudList> </MudPaper> <MudCard> <MudCardContent> <MudTextField @bind-Value=\"_newTodo\" Variant=\"Variant.Filled\" Label=\"New Todo\" /> </MudCardContent> <MudCardActions> <MudButton Variant=\"Variant.Outlined\" OnClick=\"CreateTodoItem\">Add Todo</MudButton> </MudCardActions> </MudCard> </MudStack> </MudItem> <MudItem xs=\"12\" lg=\"6\"> <MudStack> <MudBadge Content=\"@CompletedTodosCount\" Color=\"Color.Secondary\"> <MudText Typo=\"Typo.h5\">Completed Todos</MudText> </MudBadge> <MudPaper> <MudList T=\"TodoItem\"> @foreach (var todo in CompletedTodos) { <MudListItem @key=\"todo.Id\"> <MudStack Row Justify=\"Justify.SpaceBetween\" AlignItems=\"AlignItems.Center\"> <MudIconButton Icon=\"@Icons.Material.Filled.CheckBox\" OnClick=\"() => ToggleTodoItem(todo.Id)\"/> <MudText Style=\"text-decoration: line-through;\">@todo.Title</MudText> <MudSpacer/> <MudButton Variant=\"Variant.Outlined\" Color=\"Color.Error\" OnClick=\"() => DeleteTodoItem(todo.Id)\">Delete</MudButton> </MudStack> </MudListItem> } </MudList> </MudPaper> </MudStack> </MudItem> </MudGrid> @code { private string _newTodo = string.Empty; // Using Selectors as Properties private ImmutableList<TodoItem> ActiveTodos => State.SelectActiveTodos(); private int ActiveTodosCount => State.SelectActiveTodosCount(); private bool HasActiveTodos => State.SelectActiveTodosCount() > 0; private ImmutableList<TodoItem> CompletedTodos => State.SelectCompletedTodos(); private int CompletedTodosCount => State.SelectCompletedTodosCount(); private void CreateTodoItem() { if (!string.IsNullOrWhiteSpace(_newTodo)) { Dispatch(new CreateTodoItem(_newTodo)); _newTodo = string.Empty; } } private void ToggleTodoItem(Guid id) { Dispatch(new ToggleTodoItem(id)); } private void DeleteTodoItem(Guid id) { Dispatch(new DeleteTodoItem(id)); } } In this example: Selectors as Properties: The component defines properties like ActiveTodos, ActiveTodosCount, and HasActiveTodos that use selectors to access state. This keeps the markup clean and the logic encapsulated. Clean Markup: The componentâ€™s markup is clean and focused on UI elements, with the business logic separated into the @code section. Reusability: The selector-based properties can be reused in other components, promoting consistency and reducing code duplication. Best Practices for Using Selectors in Blazor Encapsulate Logic: Use selectors within your state classes to encapsulate data retrieval logic, keeping your components focused on rendering UI. Separate Markup and Logic: Define properties in your components that use selectors. This approach keeps your Razor markup clean and easy to maintain. Leverage Memoization: For expensive computations or derived data, use memoized selectors to optimize performance. Reusability: Reuse selectors across your application to maintain consistency and avoid duplicating logic."
  },
  "general/core-concepts/state-management.html": {
    "href": "general/core-concepts/state-management.html",
    "title": "State Management | R3dux Documentation",
    "keywords": "State Management Global state in R3dux provides a powerful mechanism for managing application-wide data in a predictable and maintainable way. By centralizing your state and handling all changes through actions and reducers, you can build applications that are easier to understand, debug, and scale. State management is a crucial aspect of modern application development, especially as applications grow in complexity. R3dux makes it simple to implement global state management in your .NET applications, ensuring that your application state is consistent, predictable, and easily accessible from any part of your application. What is Global State? Global state refers to a single, centralized state that holds the entire application's data. Unlike local state, which is confined to individual components or modules, global state is accessible throughout the application. This allows different parts of your application to share data and stay synchronized. Key Characteristics of Global State Single Source of Truth: The global state serves as the single source of truth for your application. All components and services that need to read or modify state must interact with this centralized store. Accessibility: Global state is accessible from any part of your application. This means that data can be easily shared between different components, pages, or services, ensuring consistency across your application. Predictability: By managing all state changes through a centralized mechanism (such as actions and reducers), global state makes it easier to track, debug, and predict how state evolves over time. How Global State Works in R3dux In R3dux, global state is managed using a centralized store. This store holds the entire application state and is responsible for updating the state in response to actions. Components of State Management in R3dux Store: The store is the core of the R3dux state management system. It holds the global state and provides methods to access the state, dispatch actions, and subscribe to state changes. Actions: Actions are simple objects that describe the type of change that should occur in the state. They are dispatched to the store to trigger state updates. Reducers: Reducers are pure functions that take the current state and an action, and return a new state. They define how the state should change in response to each action. Selectors: Selectors are functions that allow you to retrieve specific pieces of the global state. They are used to encapsulate and optimize access to the state. Example of Global State in Action Let's consider a simple example of global state management using R3dux in a Blazor application. Defining the Global State Suppose we have a counter application. The global state could be as simple as an integer representing the current count: public class CounterReducers : SliceReducers<int> { public CounterReducers() { On<Increment>((state, _) => state + 1); On<Decrement>((state, _) => state - 1); } public override int GetInitialState() { return 0; } } In this example: The global state is represented by an integer. The Increment and Decrement actions are used to modify the state. Accessing and Modifying Global State In a Blazor component, you can access and modify the global state through R3dux as follows: @page \"/counter\" @inherits R3duxComponent<int> <h3>Counter</h3> <p>Current count: @State</p> <button class=\"btn btn-primary\" @onclick=\"Increment\">Increment</button> <button class=\"btn btn-secondary\" @onclick=\"Decrement\">Decrement</button> @code { private void Increment() { Dispatch(new Increment()); } private void Decrement() { Dispatch(new Decrement()); } } In this Blazor component: The global state is automatically injected into the component via R3duxComponent<int>. The State property reflects the current global state (i.e., the counter value). The Dispatch method is used to modify the state by dispatching actions. Benefits of Using Global State Consistency: Since all components read from and write to the same state, it's easy to maintain consistency across your application. Debugging: Centralized state management simplifies the process of tracking down bugs and understanding how state changes over time. Scalability: As your application grows, managing state through a global store can help you avoid the pitfalls of prop drilling and other common state management issues. When to Use Global State Global state is particularly useful in applications where multiple components need to share and synchronize data. However, it's essential to balance the use of global state with local state, which is more appropriate for managing component-specific data."
  },
  "general/examples/README.html": {
    "href": "general/examples/README.html",
    "title": "Examples | R3dux Documentation",
    "keywords": "Examples The examples directory contains a collection of example applications that demonstrate various features and use cases of R3dux. Each example includes a detailed explanation of the application's functionality, code snippets, and instructions on how to run the example locally. Page Description Counter Example Simple counter application. Todo List Example Todo list application with various features. API Data Fetching Example Example showing how to fetch data from an API. Real-time Updates Example Example of an application with real-time updates."
  },
  "general/examples/api-data-fetching-example.html": {
    "href": "general/examples/api-data-fetching-example.html",
    "title": "API Data Fetching Example | R3dux Documentation",
    "keywords": "API Data Fetching Example"
  },
  "general/examples/counter-example.html": {
    "href": "general/examples/counter-example.html",
    "title": "Counter Example | R3dux Documentation",
    "keywords": "Counter Example"
  },
  "general/examples/real-time-updates-example.html": {
    "href": "general/examples/real-time-updates-example.html",
    "title": "Real-time Updates Example | R3dux Documentation",
    "keywords": "Real-time Updates Example"
  },
  "general/examples/todo-list-example.html": {
    "href": "general/examples/todo-list-example.html",
    "title": "Todo List Example | R3dux Documentation",
    "keywords": "Todo List Example"
  },
  "general/faq/README.html": {
    "href": "general/faq/README.html",
    "title": "FAQ | R3dux Documentation",
    "keywords": "FAQ This section provides answers to common questions and issues that you may encounter while using R3dux. Page Description Common Questions List of frequently asked questions. Troubleshooting Common issues and their solutions."
  },
  "general/faq/common-questions.html": {
    "href": "general/faq/common-questions.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/faq/troubleshooting.html": {
    "href": "general/faq/troubleshooting.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/getting-started/README.html": {
    "href": "general/getting-started/README.html",
    "title": "Getting started | R3dux Documentation",
    "keywords": "Getting started This section provides a step-by-step guide to install R3dux and create a simple application using the framework. Page Description Installation Step-by-step guide to install R3dux. Quick Start Guide Create a simple R3dux application from scratch. Quick Start Guide Blazor Set up R3dux in a Blazor application. AppSettings Configure application settings such as logging levels and allowed hosts."
  },
  "general/getting-started/app-settings.html": {
    "href": "general/getting-started/app-settings.html",
    "title": "AppSettings | R3dux Documentation",
    "keywords": "AppSettings The appsettings.json file in an ASP.NET Core application is used to configure application settings such as logging levels, allowed hosts, and custom configuration sections. Here is an example of a typical appsettings.json file used by the R3dux framework: R3dux uses the appsettings.json configuration to set up and register services. { \"Logging\": { \"LogLevel\": { \"Default\": \"Information\", \"Microsoft.AspNetCore\": \"Warning\", \"R3dux\": \"Debug\", \"R3dux.Blazor\": \"Debug\" } }, \"AllowedHosts\": \"*\", \"R3dux\": { \"AssemblyNames\": [ \"Demo.App\", // Your website \"Demo.AppStore\" // If you have your Store in another assembly ] } } Configuration Sections Logging The Logging section configures the logging levels for different parts of the application. The LogLevel subsection specifies the minimum log level for different logging categories. R3dux and R3dux.Blazor: The logging levels specifically for the R3dux framework and Blazor components. AllowedHosts The AllowedHosts setting specifies the hosts that are allowed to access the application. The wildcard * allows any host. R3dux The R3dux section contains custom settings specific to the R3dux framework: AssemblyNames: An array of assembly names that the R3dux framework will scan for slices and effects. This allows the framework to dynamically discover and register services."
  },
  "general/getting-started/installation.html": {
    "href": "general/getting-started/installation.html",
    "title": "Installation | R3dux Documentation",
    "keywords": "Installation This page will guide you through the process of installing R3dux in your .NET applications. Follow the steps below to get started quickly and easily. Prerequisites Before you install R3dux, ensure that you have the following prerequisites: .NET SDK: R3dux requires .NET SDK version 8.0 or later. You can download and install the .NET SDK from the official .NET website. dotnet --version This command should return a version number of 8.0 or later. Integrated Development Environment (IDE): While you can use any text editor to develop .NET applications, we recommend using an IDE like Visual Studio, Visual Studio Code, or Rider for a better development experience. Installing via NuGet R3dux is available as a NuGet package. You can install it using the NuGet Package Manager in Visual Studio, the .NET CLI, or the Package Manager Console. Using the .NET CLI Open a terminal or command prompt. Navigate to your project directory. Run the following command to install R3dux: dotnet add package R3dux dotnet add package R3dux.Blazor Using the Package Manager Console in Visual Studio Open your solution in Visual Studio. Go to Tools > NuGet Package Manager > Package Manager Console. Run the following command in the Package Manager Console: Install-Package R3dux Install-Package R3dux.Blazor Using the NuGet Package Manager in Visual Studio Open your solution in Visual Studio. Right-click on your project in the Solution Explorer and select Manage NuGet Packages. In the NuGet Package Manager, search for \"R3dux\". Select the R3dux package from the list and click Install. Verifying the Installation To verify that R3dux is installed correctly, you can check your project's dependencies: Open your project file (e.g., .csproj). Ensure that there is a reference to R3dux: <ItemGroup> <PackageReference Include=\"R3dux\" Version=\"1.0.0\" /> <PackageReference Include=\"R3dux.Blazor\" Version=\"1.0.0\" /> </ItemGroup> Once you have completed these steps, R3dux should be installed and ready to use in your project. You can now start integrating R3dux into your .NET applications to manage state effectively."
  },
  "general/getting-started/quick-start-guide-blazor.html": {
    "href": "general/getting-started/quick-start-guide-blazor.html",
    "title": "Quick Start Guide for Blazor | R3dux Documentation",
    "keywords": "Quick Start Guide for Blazor This guide will help you set up R3dux in a Blazor application. By following these steps, you'll integrate R3dux for state management and implement a simple counter example. Create Project & Install R3dux 1. Create a New Blazor Project First, create a new Blazor WebAssembly project using the .NET CLI: dotnet new blazorwasm -o BlazorApp cd BlazorApp 2. Install R3dux and R3dux.Blazor Next, install R3dux and the R3dux.Blazor package using the .NET CLI: dotnet add package R3dux dotnet add package R3dux.Blazor Prepare Startup To configure R3dux in your Blazor application, you'll need to update your Program.cs file. 1. Configure R3dux in Program.cs Open the Program.cs file and add the R3dux services to the Blazor service container. Basic Configuration If your slices are automatically discoverable, you can use the basic configuration: using R3dux.Blazor; var builder = WebAssemblyHostBuilder.CreateDefault(args); builder.RootComponents.Add<App>(\"#app\"); // Add R3dux with automatic assembly scanning builder.Services.AddR3dux(builder.Configuration); await builder.Build().RunAsync(); Advanced Configuration If you want more control, for example, specifying which assemblies to scan for slices, use the following configuration: using R3dux.Blazor; var builder = WebAssemblyHostBuilder.CreateDefault(args); builder.RootComponents.Add<App>(\"#app\"); // Add R3dux with specific assemblies builder.Services.AddR3dux(options => { options.Assemblies = new[] { typeof(CounterSlice).Assembly }; }); await builder.Build().RunAsync(); Implement a Counter Example Now that R3dux is set up, letâ€™s implement a simple counter example in your Blazor application. 1. Define Actions Create a new file called CounterActions.cs in the Shared folder: public record Increment : IAction; public record Decrement : IAction; 2. Define Reducers Create a new file called CounterReducers.cs in the Shared folder: public class CounterReducers : SliceReducers<int> { public CounterReducers() { On<Increment>((state, _) => state + 1); On<Decrement>((state, _) => state - 1); } public override int GetInitialState() { return 0; } } 3. Update the Counter Component Now, let's modify the default Counter.razor component to use R3dux. Update Counter.razor Replace the contents of the Counter.razor component with the following: @page \"/counter\" @inherits R3duxComponent<int> <h3>Counter</h3> <p>Current count: @State</p> <button class=\"btn btn-primary\" @onclick=\"Increment\">Increment</button> <button class=\"btn btn-secondary\" @onclick=\"Decrement\">Decrement</button> @code { private void Increment() { Dispatch(new Increment()); } private void Decrement() { Dispatch(new Decrement()); } } 4. Run Your Blazor Application You can now run your Blazor application using the following command: dotnet run 5. View the Counter Component Navigate to /counter in your web browser. You should see a counter that increments and decrements as you click the respective buttons. Understanding the Example Actions: The Increment and Decrement actions are simple records that describe state changes. Reducers: The CounterReducers class defines how the state changes in response to the dispatched actions. R3duxComponent: The Counter.razor component inherits from R3duxComponent<int>, automatically binding the state to the component. Dispatch: The Dispatch method is used to send actions to the store, triggering state updates."
  },
  "general/getting-started/quick-start-guide.html": {
    "href": "general/getting-started/quick-start-guide.html",
    "title": "Quick Start Guide | R3dux Documentation",
    "keywords": "Quick Start Guide Welcome to the R3dux Quick Start Guide! This guide will help you get up and running with R3dux in your .NET application. By the end of this guide, you'll have a basic understanding of how to set up a project with R3dux and implement a simple state management example. Setting Up Your First Project 1. Create a New .NET Project To get started, you'll need to create a new .NET project. You can create a console application, a Blazor application, or any other type of .NET project where you want to manage state using R3dux. Using the .NET CLI Open your terminal or command prompt and run the following commands to create a new .NET console application: dotnet new console -n R3duxDemo cd R3duxDemo This creates a new directory called R3duxDemo containing a basic .NET console application. 2. Install R3dux Next, you need to install R3dux via NuGet. Using the .NET CLI Run the following command to install R3dux: dotnet add package R3dux 3. Set Up Your Project for R3dux In your project, you'll need to define actions, reducers, and optionally effects. For this quick start, we'll keep it simple and create a counter example. Define Actions Create a new file called CounterActions.cs: public record Increment : IAction; public record Decrement : IAction; Define Reducers Create a new file called CounterReducers.cs: public class CounterReducers : SliceReducers<int> { public CounterReducers() { On<Increment>((state, _) => state + 1); On<Decrement>((state, _) => state - 1); } public override int GetInitialState() { return 0; } } Set Up the Store In your Program.cs file (or equivalent entry point), set up the R3dux store: using R3dux; class Program { static void Main(string[] args) { var store = new Store(new CounterReducers()); store.Dispatch(new Increment()); Console.WriteLine($\"Counter: {store.GetState<int>()}\"); store.Dispatch(new Increment()); Console.WriteLine($\"Counter: {store.GetState<int>()}\"); store.Dispatch(new Decrement()); Console.WriteLine($\"Counter: {store.GetState<int>()}\"); } } Basic Usage Example Now that your project is set up, let's go over the basic usage of R3dux by running the counter example. 1. Run the Application You can run your application by executing the following command in your terminal: dotnet run 2. Observe the Output After running the application, you should see the following output: Counter: 1 Counter: 2 Counter: 1 3. Understanding the Example Actions: Increment and Decrement are simple actions that describe state changes. These are dispatched to the store to trigger state updates. Reducers: The CounterReducers class defines how the state should change in response to each action. The On method maps actions to state changes. Store: The Store class manages the application state. You can dispatch actions to the store and retrieve the current state using GetState. This example demonstrates how to set up a simple counter using R3dux. The state is managed in a predictable and immutable way, and actions are the only way to modify the state."
  },
  "general/guidelines/README.html": {
    "href": "general/guidelines/README.html",
    "title": "Guidelines | R3dux Documentation",
    "keywords": "Guidelines This folder contains guidelines on procedure, best practices and more. You can have a more elaborate landing page for this section if the number of guidelines grow. You can group guidelines in sub-folders, but also just in text on this landing page. This is an example how that could be structured. Modify for your project. Fundamentals Other options Fundamentals Documentation guidelines Other options Tip Other guidelines you can add here can be used from CSE Playbook - Source Control, like branch naming, merge strategies and such."
  },
  "general/guidelines/docs-guidelines.html": {
    "href": "general/guidelines/docs-guidelines.html",
    "title": "Documentation guidelines | R3dux Documentation",
    "keywords": "Documentation guidelines Folder structure All documentation is stored in the /docs folder. In that folder there are standard defined sub-folders: architecture-decisions - All architecture decisions are documented here. Everything lands in the decision log in the root of the docs folder. All decisions that need more explanation than a one line will have separate docs here. getting-started - Limited documentation with the purpose of helping new people on the team to get started and setup. guidelines - General guidelines for the project. working-agreements - All working agreements. developer - All documentation important for developers, including how to's. Sub-folders and entry document When adding documents think about the location it should be added to. Prevent a folder with lots of markdown files as it is harder to have an overview. It's better to group markdown files in sub-folders with sensible names. Tip Prevent creating folders in the root level as much as possible. Once all documents are generated into the documentation website, all folders will have an entry document. You can provide your own entry document by providing a README.md or INDEX.md in the folder. If you don't provide either of them, an INDEX.md is generated with a list of directories and files in the folder when the TocDocFxCreation tool is used. You can also order the files and directories in a folder. This can be done by using a .order file in each folder. This is a text-file that just lists the filename without extension and/or directory names in a particular order. These names are case-sensitive. See documentation on the Azure DevOps WIKI .order file for more information. Markdownlint Standard documentation is writting using Markdown files (MD). Markdownlint should be used to check for properly structured markdown syntax. This is needed for the generation of static HTML documentation. You can use Mardownlint extension for Visual Studio code to get these checks and helps while you type in Visual Studio code. Use of images and other attachments If you are writing a document and you have images or other files attached to that document, these extra files must be place in the /docs/.attachments folder. This is because of how DocFX is working, which is being used to generate documentation including API documentation from the source code. Also, the DocLinkChecker tool uses this location to validate documents versus attachments for orphaned items."
  },
  "general/guides/README.html": {
    "href": "general/guides/README.html",
    "title": "Guides | R3dux Documentation",
    "keywords": "Guides Guides provide detailed instructions on how to use R3dux to build applications. They cover various topics such as creating actions, writing reducers, handling side effects, using selectors, and more. Page Description Creating and Dispatching Actions Detailed guide on creating and dispatching actions. Writing Reducers Step-by-step instructions on writing reducers. Handling Side Effects with Effects Guide on writing and using effects. Using Selectors Instructions on creating and using selectors."
  },
  "general/guides/creating-and-dispatching-actions.html": {
    "href": "general/guides/creating-and-dispatching-actions.html",
    "title": "Creating and Dispatching Actions | R3dux Documentation",
    "keywords": "Creating and Dispatching Actions"
  },
  "general/guides/handling-side-effects-with-effects.html": {
    "href": "general/guides/handling-side-effects-with-effects.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/guides/using-selectors.html": {
    "href": "general/guides/using-selectors.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/guides/writing-reducers.html": {
    "href": "general/guides/writing-reducers.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/introduction/README.html": {
    "href": "general/introduction/README.html",
    "title": "Introduction | R3dux Documentation",
    "keywords": "Introduction Here, you will find an overview of R3dux, its key features, philosophy, and goals, as well as licensing information. These resources will help you understand the core concepts and principles behind R3dux and guide you in using the library effectively. Page Description Overview What R3dux is and why it was created. Key Features Highlight major features like immutability, effects, and modularity. Philosophy and Goals Explain the design philosophy and goals behind R3dux. License Information Provide details about the Apache-2.0 license."
  },
  "general/introduction/key-features.html": {
    "href": "general/introduction/key-features.html",
    "title": "Key Features | R3dux Documentation",
    "keywords": "Key Features R3dux is a powerful state management library designed to simplify and enhance the development of .NET applications. Here are some of the key features that make R3dux an excellent choice for managing application state: Immutable State Management R3dux enforces immutable state management, ensuring that state changes are predictable and trackable. This immutability guarantees that the state is never modified directly but always through actions and reducers, making debugging and testing more straightforward. Benefits: Predictable state changes Easier debugging and testing Prevention of accidental state mutations Actions Actions in R3dux are simple objects that describe a state change. They are the only way to send data to the store, ensuring a clear and consistent way to update the state. Features: Clear and explicit state changes Easy to track and log actions Supports asynchronous operations through effects Reducers Reducers are pure functions that take the current state and an action, and return a new state. They are responsible for handling state transitions in a predictable manner. Features: Pure functions ensure consistency Easily testable Supports composition for managing complex state trees Effects Effects handle side effects in R3dux, such as asynchronous API calls, logging, and other operations that interact with the outside world. They listen for specific actions and can dispatch new actions based on the outcome. Features: Clean separation of side effects from state logic Supports asynchronous operations Simplifies handling of complex side effects Selectors Selectors are functions that derive and memoize state. They allow you to compute derived state efficiently, ensuring that your components re-render only when necessary. Features: Efficient state derivation Memoization for performance optimization Composable and reusable Type Safety R3dux leverages the strong typing system of .NET to provide type safety throughout your application. This ensures that your actions, reducers, and state are type-checked, reducing runtime errors and improving code quality. Features: Strongly typed actions and state Compile-time type checking Reduced runtime errors Performance Optimization R3dux is designed with performance in mind. It supports memoization, efficient state updates, and minimizes unnecessary re-renders, ensuring that your application remains responsive and performant. Features: Memoized selectors Efficient state updates Minimized re-renders Easy Integration R3dux is designed to integrate seamlessly with other libraries and frameworks. Whether you are using it in a Blazor application, an ASP.NET Core project, or any other .NET application, R3dux can be easily integrated to manage your application state. Features: Seamless integration with .NET applications Compatible with Blazor, ASP.NET Core, and more Flexible and adaptable to different architectures"
  },
  "general/introduction/license-information.html": {
    "href": "general/introduction/license-information.html",
    "title": "License Information | R3dux Documentation",
    "keywords": "License Information R3dux is licensed under the Apache License, Version 2.0. This license allows users to freely use, modify, and distribute the software, subject to certain conditions. Below, you will find an overview of the key points of the Apache v2 license and what it means for you as a user or contributor. Apache License, Version 2.0 Key Points Freedom to Use: You are free to use R3dux in your personal or commercial projects without any restrictions. Freedom to Modify: You can modify the source code of R3dux to suit your needs. Freedom to Distribute: You are allowed to distribute the original or modified versions of R3dux. Patent Grant: The license provides an express grant of patent rights from contributors to users. Conditions Notice: You must include a copy of the Apache License, Version 2.0, in any distribution of R3dux. State Changes: If you modify the code and distribute it, you must document the changes you made. No Trademark Use: The license does not grant permission to use the trade names, trademarks, service marks, or product names of the licensors, except as required to describe the origin of the software. No Warranty: The software is provided \"as is\", without warranty of any kind, express or implied. For the full text of the license, please visit the Apache License, Version 2.0."
  },
  "general/introduction/overview.html": {
    "href": "general/introduction/overview.html",
    "title": "Overview | R3dux Documentation",
    "keywords": "Overview What you will learn What R3dux is and why you might want to use it Key R3dux terms and concepts How data flows through a R3dux app Introduction R3dux Terms and Concepts Before we dive into some actual code, let's talk about some of the terms and concepts you'll need to know to use R3dux. State Management Let's start by looking at a small Blazor counter component. It tracks a number in component state, and increments the number when a button is clicked: <!-- View: the UI definition --> <div> Value: @counter <button onClick=\"Increment\">Increment</button> </div> @code { // State: a counter value private int counter = 0; // Action: code that causes an update to the state when something happens private void Increment() { counter = counter + 1; } } It is a self-contained app with the following parts: The state, the source of truth that drives our app; The view, a declarative description of the UI based on the current state The actions, the events that occur in the app based on user input, and trigger updates in the state This is a small example of \"one-way data flow\": State describes the condition of the app at a specific point in time The UI is rendered based on that state When something happens (such as a user clicking a button), the state is updated based on what occurred The UI re-renders based on the new state However, the simplicity can break down when we have multiple components that need to share and use the same state, especially if those components are located in different parts of the application. Sometimes this can be solved by \"using cascading values and cascading parameterslifting state up\" to parent components, but that doesn't always help. One way to solve this is to extract the shared state from the components, and put it into a centralized location outside the component tree. With this, our component tree becomes a big \"view\", and any component can access the state or trigger actions, no matter where they are in the tree! By defining and separating the concepts involved in state management and enforcing rules that maintain independence between views and states, we give our code more structure and maintainability. This is the basic idea behind R3dux: a single centralized place to contain the global state in your application, and specific patterns to follow when updating that state to make the code predictable."
  },
  "general/introduction/philosophy-and-goals.html": {
    "href": "general/introduction/philosophy-and-goals.html",
    "title": "Philosophy and Goals | R3dux Documentation",
    "keywords": "Philosophy and Goals R3dux is built with a clear philosophy and a set of goals aimed at providing a robust, predictable, and flexible state management solution for .NET applications. Understanding the core philosophy and goals behind R3dux can help you make the most of this library and align your development practices with its design principles. Philosophy Predictability One of the core tenets of R3dux is to ensure that state changes are predictable. By using a clear, unidirectional data flow and enforcing immutable state updates, R3dux makes it easy to understand how and why the state changes in your application. Unidirectional Data Flow: Actions describe what happens, reducers dictate how the state changes, and the updated state is then reflected in your application. Immutability: State is never mutated directly. Instead, new state objects are created for each update, making it easy to track changes and maintain history. Simplicity R3dux aims to keep the complexity of state management low, even in large and complex applications. The library provides a straightforward API that developers can easily learn and use, without compromising on the power and flexibility needed for advanced use cases. Clear API: A concise and intuitive API helps in reducing the learning curve and boosts productivity. Minimal Boilerplate: R3dux minimizes the amount of boilerplate code required to manage state, allowing developers to focus on building features rather than wiring up the state management. Flexibility R3dux is designed to be flexible and adaptable to various application architectures and requirements. Whether you're building a small application or a large-scale enterprise solution, R3dux can be tailored to fit your needs. Modular Architecture: The modular design allows you to use only the parts of the library you need, making it lightweight and efficient. Compatibility: R3dux integrates seamlessly with different .NET applications, including Blazor and ASP.NET Core, and can be used alongside other libraries and frameworks. Goals Robust State Management R3dux aims to provide a robust solution for managing application state. It ensures that your application's state is always consistent and that state transitions are well-defined and predictable. Consistency: Ensures that the state remains consistent and accurate across the application. Error Handling: Provides mechanisms for handling errors gracefully, ensuring that your application can recover from unexpected situations. High Performance Performance is a key goal for R3dux. The library is designed to be efficient in terms of both memory usage and execution speed, ensuring that your application remains responsive even as it scales. Efficient State Updates: Uses immutable data structures and memoization to optimize state updates and reduce unnecessary re-renders. Scalability: Designed to handle large state trees and complex state management scenarios without sacrificing performance. Strong Typing Leveraging the strong typing system of .NET, R3dux aims to provide type safety throughout your application. This reduces runtime errors and enhances code quality. Type Safety: Ensures that actions, reducers, and state are type-checked at compile time, reducing the likelihood of errors. Enhanced Developer Experience: Type safety improves the developer experience by providing better tooling support and reducing the need for extensive runtime checks. Ease of Use R3dux is built with the developer experience in mind. It provides a simple and intuitive API that makes it easy to manage state, handle side effects, and integrate with other parts of your application. Developer Productivity: Helps developers be more productive by providing clear guidelines and reducing boilerplate code. Comprehensive Documentation: Offers thorough documentation and examples to help developers get started quickly and effectively."
  },
  "general/resources/README.html": {
    "href": "general/resources/README.html",
    "title": "Resources | R3dux Documentation",
    "keywords": "Resources Resources for learning more about R3dux and related topics. Page Description Tutorials and Blog Posts List of tutorials and blog posts about R3dux. Videos and Talks Links to videos and talks about R3dux. Related Projects Other projects that complement or extend R3dux."
  },
  "general/resources/related-projects.html": {
    "href": "general/resources/related-projects.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/resources/tutorials-and-blog-posts.html": {
    "href": "general/resources/tutorials-and-blog-posts.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/resources/videos-and-talks.html": {
    "href": "general/resources/videos-and-talks.html",
    "title": "| R3dux Documentation",
    "keywords": ""
  },
  "general/templates/README.html": {
    "href": "general/templates/README.html",
    "title": "Templates | R3dux Documentation",
    "keywords": "Templates You can include templates for various standard documents in your project here. Tip Good templates can be found on CSE Playbook, for instance: CSE Playbook - pull request template CSE Playbook - automated testing templates CSE Playbook - decision log"
  },
  "general/working-agreements/README.html": {
    "href": "general/working-agreements/README.html",
    "title": "Working Agreements | R3dux Documentation",
    "keywords": "Working Agreements You can include working agreements in this folder. Tip Use template documents like working agreements and such from the CSE Playbook - Team Agreements."
  },
  "index.html": {
    "href": "index.html",
    "title": "R3dux Documentation | R3dux Documentation",
    "keywords": "R3dux Documentation This is the landing page of the R3dux Documentation website. You can add specific links that are important to provide direct access. Tip Try not to duplicate the links on the top of the page, unless it really makes sense. To get started with the setup of this website, read the getting started document with the title Using DocFx and Companion Tools. Style of this website This documentation website is currently setup with the basics of the DocFx Material style added with the Microsoft logo. The combination can be found in /QuickStart/docfx/template. In the template we also enabled diagram support through Mermaid."
  },
  "reference/R3dux.Abstractions.IAction.html": {
    "href": "reference/R3dux.Abstractions.IAction.html",
    "title": "Interface IAction | R3dux Documentation",
    "keywords": "Interface IAction Defines a contract for an action. Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface IAction"
  },
  "reference/R3dux.Abstractions.IDispatcher.html": {
    "href": "reference/R3dux.Abstractions.IDispatcher.html",
    "title": "Interface IDispatcher | R3dux Documentation",
    "keywords": "Interface IDispatcher Defines the contract for a dispatcher that can dispatch actions and provide an observable stream of dispatched actions. Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface IDispatcher Properties | Edit this page View Source ActionStream Gets an observable stream of dispatched actions. Declaration Observable<IAction> ActionStream { get; } Property Value Type Description Observable<IAction> Methods | Edit this page View Source Dispatch(IAction) Dispatches the specified action. Declaration void Dispatch(IAction action) Parameters Type Name Description IAction action The action to dispatch. Exceptions Type Condition ArgumentNullException Thrown when the action is null. ObjectDisposedException Thrown when the dispatcher has been disposed."
  },
  "reference/R3dux.Abstractions.IEffect.html": {
    "href": "reference/R3dux.Abstractions.IEffect.html",
    "title": "Interface IEffect | R3dux Documentation",
    "keywords": "Interface IEffect Represents an effect that handles a stream of actions and interacts with the store's state. Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface IEffect Methods | Edit this page View Source GetAssemblyName() Gets the assembly-qualified name of the effect. Declaration string GetAssemblyName() Returns Type Description string The assembly-qualified name of the effect. | Edit this page View Source GetKey() Gets the key that identifies the effect. Declaration string GetKey() Returns Type Description string The key that identifies the effect. | Edit this page View Source Handle(Observable<IAction>, Observable<IRootState>) Handles a stream of actions and produces a stream of resulting actions. Declaration Observable<IAction> Handle(Observable<IAction> actions, Observable<IRootState> rootState) Parameters Type Name Description Observable<IAction> actions The source observable sequence of actions. Observable<IRootState> rootState The source observable sequence of the root state. Returns Type Description Observable<IAction> An observable sequence of resulting actions."
  },
  "reference/R3dux.Abstractions.IKeyedAction.html": {
    "href": "reference/R3dux.Abstractions.IKeyedAction.html",
    "title": "Interface IKeyedAction | R3dux Documentation",
    "keywords": "Interface IKeyedAction Defines a contract for an action with a type key. Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface IKeyedAction : IAction Properties | Edit this page View Source TypeKey Gets the type of an action identifies to the consumer the nature of the action that has occurred. Declaration string TypeKey { get; } Property Value Type Description string"
  },
  "reference/R3dux.Abstractions.IRootState.html": {
    "href": "reference/R3dux.Abstractions.IRootState.html",
    "title": "Interface IRootState | R3dux Documentation",
    "keywords": "Interface IRootState Represents the root state of the application, managing slice states. Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface IRootState Methods | Edit this page View Source ContainsKey(string) Determines whether the state contains an element with the specified key. Declaration bool ContainsKey(string key) Parameters Type Name Description string key The key to locate in the state. Returns Type Description bool true if the state contains an element with the key; otherwise, false. | Edit this page View Source GetKeys() Gets the keys of the state. Declaration ImmutableSortedSet<string> GetKeys() Returns Type Description ImmutableSortedSet<string> The keys of the state. | Edit this page View Source GetSliceState<TState>() Gets the slice state of the specified type. Declaration TState GetSliceState<TState>() where TState : notnull Returns Type Description TState The state of the specified type. Type Parameters Name Description TState The type of the state to select. | Edit this page View Source GetSliceState<TState>(string) Gets the slice state associated with the specified key. Declaration TState GetSliceState<TState>(string key) where TState : notnull Parameters Type Name Description string key The key of the state to select. Returns Type Description TState The state associated with the specified key. Type Parameters Name Description TState The type of the state to select. | Edit this page View Source GetStateDictionary() Gets the underlying state dictionary for serialization purposes. Declaration ImmutableSortedDictionary<string, object> GetStateDictionary() Returns Type Description ImmutableSortedDictionary<string, object> The state dictionary."
  },
  "reference/R3dux.Abstractions.IRootStateSerializer.html": {
    "href": "reference/R3dux.Abstractions.IRootStateSerializer.html",
    "title": "Interface IRootStateSerializer | R3dux Documentation",
    "keywords": "Interface IRootStateSerializer Provides methods for serializing and deserializing IRootState instances. Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface IRootStateSerializer Methods | Edit this page View Source Deserialize(string) Deserializes a IRootState from a JSON string. Declaration IRootState Deserialize(string json) Parameters Type Name Description string json The JSON string representation of the state. Returns Type Description IRootState A new instance of IRootState with the deserialized state. | Edit this page View Source LoadFromFile(string) Loads a IRootState from a file. Declaration IRootState LoadFromFile(string filePath) Parameters Type Name Description string filePath The path of the file to load the state from. Returns Type Description IRootState A new instance of IRootState with the loaded state. | Edit this page View Source SaveToFile(IRootState, string) Saves the specified IRootState to a file. Declaration void SaveToFile(IRootState rootState, string filePath) Parameters Type Name Description IRootState rootState The IRootState to save. string filePath The path of the file to save the state to. | Edit this page View Source Serialize(IRootState) Serializes the specified IRootState to a JSON string. Declaration string Serialize(IRootState rootState) Parameters Type Name Description IRootState rootState The IRootState to serialize. Returns Type Description string The JSON string representation of the state. | Edit this page View Source Serialize(IRootState, string) Serializes the slice state associated with the specified key to a JSON string. Declaration string Serialize(IRootState rootState, string key) Parameters Type Name Description IRootState rootState The IRootState to serialize. string key The key of the slice state to serialize. Returns Type Description string The JSON string representation of the slice state."
  },
  "reference/R3dux.Abstractions.ISlice-1.html": {
    "href": "reference/R3dux.Abstractions.ISlice-1.html",
    "title": "Interface ISlice<TState> | R3dux Documentation",
    "keywords": "Interface ISlice<TState> Represents a strongly-typed state slice with state management and reducers. Inherited Members ISlice.StateUpdated ISlice.GetKey() ISlice.GetStateType() ISlice.GetState() ISlice.OnDispatch(IAction) Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface ISlice<TState> : ISlice Type Parameters Name Description TState The type of the state managed by this slice. Properties | Edit this page View Source Reducers Gets the collection of reducers for this state slice. Declaration Dictionary<Type, Func<TState, IAction, TState>> Reducers { get; } Property Value Type Description Dictionary<Type, Func<TState, IAction, TState>> The collection of reducers. | Edit this page View Source State Gets an observable sequence that produces the state of this slice. Declaration Observable<TState> State { get; } Property Value Type Description Observable<TState> The observable sequence of the state."
  },
  "reference/R3dux.Abstractions.ISlice.html": {
    "href": "reference/R3dux.Abstractions.ISlice.html",
    "title": "Interface ISlice | R3dux Documentation",
    "keywords": "Interface ISlice Represents a state slice with basic state management capabilities. Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface ISlice Properties | Edit this page View Source StateUpdated Gets an observable sequence that produces a notification when the state is updated. Declaration Observable<Unit> StateUpdated { get; } Property Value Type Description Observable<Unit> The observable sequence of state updates. Methods | Edit this page View Source GetKey() Gets the unique key for this state slice. Declaration string GetKey() Returns Type Description string The unique key as a string. | Edit this page View Source GetState() Gets the current state of this slice. Declaration object GetState() Returns Type Description object The current state as an object. | Edit this page View Source GetStateType() Gets the type of the state managed by this slice. Declaration Type GetStateType() Returns Type Description Type The type of the state. | Edit this page View Source OnDispatch(IAction) Handles the dispatch of an action. Declaration void OnDispatch(IAction action) Parameters Type Name Description IAction action The action to be dispatched."
  },
  "reference/R3dux.Abstractions.IState.html": {
    "href": "reference/R3dux.Abstractions.IState.html",
    "title": "Interface IState | R3dux Documentation",
    "keywords": "Interface IState Represents a state object. Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public interface IState"
  },
  "reference/R3dux.Abstractions.R3duxException.html": {
    "href": "reference/R3dux.Abstractions.R3duxException.html",
    "title": "Class R3duxException | R3dux Documentation",
    "keywords": "Class R3duxException Exception type for the R3dux library. Inheritance object Exception R3duxException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Namespace: R3dux.Abstractions Assembly: R3dux.Abstractions.dll Syntax public class R3duxException : Exception, ISerializable Constructors | Edit this page View Source R3duxException() Initializes a new instance of the R3duxException class. Declaration public R3duxException() | Edit this page View Source R3duxException(string) Initializes a new instance of the R3duxException class with a specified error message. Declaration public R3duxException(string message) Parameters Type Name Description string message The message that describes the error. | Edit this page View Source R3duxException(string, Exception) Initializes a new instance of the R3duxException class with a specified error message and a reference to the inner exception that is the cause of this exception. Declaration public R3duxException(string message, Exception innerException) Parameters Type Name Description string message The message that describes the error. Exception innerException The exception that is the cause of the current exception. Implements ISerializable"
  },
  "reference/R3dux.Abstractions.html": {
    "href": "reference/R3dux.Abstractions.html",
    "title": "Namespace R3dux.Abstractions | R3dux Documentation",
    "keywords": "Namespace R3dux.Abstractions Classes R3duxException Exception type for the R3dux library. Interfaces IAction Defines a contract for an action. IDispatcher Defines the contract for a dispatcher that can dispatch actions and provide an observable stream of dispatched actions. IEffect Represents an effect that handles a stream of actions and interacts with the store's state. IKeyedAction Defines a contract for an action with a type key. IRootState Represents the root state of the application, managing slice states. IRootStateSerializer Provides methods for serializing and deserializing IRootState instances. ISlice Represents a state slice with basic state management capabilities. ISlice<TState> Represents a strongly-typed state slice with state management and reducers. IState Represents a state object."
  },
  "reference/R3dux.Blazor.DependencyInjections.html": {
    "href": "reference/R3dux.Blazor.DependencyInjections.html",
    "title": "Class DependencyInjections | R3dux Documentation",
    "keywords": "Class DependencyInjections Extension methods for adding R3dux services to the dependency injection container. Inheritance object DependencyInjections Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor Assembly: R3dux.Blazor.dll Syntax public static class DependencyInjections Methods | Edit this page View Source AddR3dux(IServiceCollection, IConfiguration, Action<R3duxOptions>?) Adds R3dux services to the specified IServiceCollection. This method registers the BlazorR3 services, dispatcher, slices, and effects. Declaration public static IServiceCollection AddR3dux(this IServiceCollection services, IConfiguration configuration, Action<R3duxOptions>? configureOptions = null) Parameters Type Name Description IServiceCollection services The IServiceCollection to add the services to. IConfiguration configuration The application configuration. Action<R3duxOptions> configureOptions An optional action to configure the R3duxOptions. Returns Type Description IServiceCollection The IServiceCollection so that additional calls can be chained. | Edit this page View Source AddR3dux(IServiceCollection, Action<R3duxOptions>?) Adds R3dux services to the specified IServiceCollection. This method registers the BlazorR3 services, dispatcher, slices, and effects. Declaration public static IServiceCollection AddR3dux(this IServiceCollection services, Action<R3duxOptions>? configureOptions = null) Parameters Type Name Description IServiceCollection services The IServiceCollection to add the services to. Action<R3duxOptions> configureOptions An optional action to configure the R3duxOptions. Returns Type Description IServiceCollection The IServiceCollection so that additional calls can be chained."
  },
  "reference/R3dux.Blazor.R3duxComponent-1.html": {
    "href": "reference/R3dux.Blazor.R3duxComponent-1.html",
    "title": "Class R3duxComponent<TState> | R3dux Documentation",
    "keywords": "Class R3duxComponent<TState> A base component class for R3dux components that manages state and dispatches actions. Inheritance object ComponentBase R3duxComponent<TState> R3duxLayout<TState> Implements IComponent IHandleEvent IHandleAfterRender IDisposable Inherited Members ComponentBase.BuildRenderTree(RenderTreeBuilder) ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) ComponentBase.SetParametersAsync(ParameterView) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor Assembly: R3dux.Blazor.dll Syntax public abstract class R3duxComponent<TState> : ComponentBase, IComponent, IHandleEvent, IHandleAfterRender, IDisposable where TState : notnull Type Parameters Name Description TState The type of the state managed by this component. Properties | Edit this page View Source ComponentName Gets the name of the component. Declaration protected string ComponentName { get; } Property Value Type Description string | Edit this page View Source Dispatcher Gets or sets the dispatcher used to dispatch actions to the store. Declaration [Inject] public required IDispatcher Dispatcher { get; set; } Property Value Type Description IDispatcher | Edit this page View Source Logger Gets or sets the logger used for logging information. Declaration [Inject] public required ILogger<R3duxComponent<object>> Logger { get; set; } Property Value Type Description ILogger<R3duxComponent<object>> | Edit this page View Source State Gets the current state of the component. Declaration protected TState State { get; } Property Value Type Description TState | Edit this page View Source Store Gets or sets the store that manages the application state. Declaration [Inject] public required R3duxStore Store { get; set; } Property Value Type Description R3duxStore Methods | Edit this page View Source Dispatch(IAction) Dispatches an action to the store. Declaration protected void Dispatch(IAction action) Parameters Type Name Description IAction action The action to dispatch. | Edit this page View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() | Edit this page View Source Dispose(bool) Releases the unmanaged resources used by the R3duxComponent<TState> and optionally releases the managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description bool disposing If true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed. If false, the method has been called by the runtime from inside the finalizer and only unmanaged resources can be disposed. | Edit this page View Source OnAfterSubscribed() Invoked after the state subscription has been established. This method is intended to be overridden by derived classes. Declaration protected virtual void OnAfterSubscribed() | Edit this page View Source OnInitialized() Method invoked when the component is ready to start, having received its initial parameters from its parent in the render tree. Declaration protected override sealed void OnInitialized() Overrides ComponentBase.OnInitialized() Implements IComponent IHandleEvent IHandleAfterRender IDisposable"
  },
  "reference/R3dux.Blazor.R3duxLayout-1.html": {
    "href": "reference/R3dux.Blazor.R3duxLayout-1.html",
    "title": "Class R3duxLayout<TState> | R3dux Documentation",
    "keywords": "Class R3duxLayout<TState> A base layout class for R3dux components that manages state and dispatches actions. Inheritance object ComponentBase R3duxComponent<TState> R3duxLayout<TState> Implements IComponent IHandleEvent IHandleAfterRender IDisposable Inherited Members R3duxComponent<TState>.Store R3duxComponent<TState>.Dispatcher R3duxComponent<TState>.Logger R3duxComponent<TState>.ComponentName R3duxComponent<TState>.State R3duxComponent<TState>.Dispose() R3duxComponent<TState>.Dispose(bool) R3duxComponent<TState>.OnAfterSubscribed() R3duxComponent<TState>.OnInitialized() R3duxComponent<TState>.Dispatch(IAction) ComponentBase.BuildRenderTree(RenderTreeBuilder) ComponentBase.OnInitializedAsync() ComponentBase.OnParametersSet() ComponentBase.OnParametersSetAsync() ComponentBase.StateHasChanged() ComponentBase.ShouldRender() ComponentBase.OnAfterRender(bool) ComponentBase.OnAfterRenderAsync(bool) ComponentBase.InvokeAsync(Action) ComponentBase.InvokeAsync(Func<Task>) ComponentBase.DispatchExceptionAsync(Exception) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor Assembly: R3dux.Blazor.dll Syntax public abstract class R3duxLayout<TState> : R3duxComponent<TState>, IComponent, IHandleEvent, IHandleAfterRender, IDisposable where TState : notnull Type Parameters Name Description TState The type of the state managed by this component. Properties | Edit this page View Source Body Gets or sets the content to be rendered inside the layout. Declaration [Parameter] public RenderFragment? Body { get; set; } Property Value Type Description RenderFragment Methods | Edit this page View Source SetParametersAsync(ParameterView) Sets parameters supplied by the component's parent in the render tree. Declaration public override Task SetParametersAsync(ParameterView parameters) Parameters Type Name Description ParameterView parameters The parameters. Returns Type Description Task A Task that completes when the component has finished updating and rendering itself. Overrides ComponentBase.SetParametersAsync(ParameterView) Remarks Parameters are passed when SetParametersAsync(ParameterView) is called. It is not required that the caller supply a parameter value for all of the parameters that are logically understood by the component. The default implementation of SetParametersAsync(ParameterView) will set the value of each property decorated with ParameterAttribute or CascadingParameterAttribute that has a corresponding value in the ParameterView. Parameters that do not have a corresponding value will be unchanged. Implements IComponent IHandleEvent IHandleAfterRender IDisposable"
  },
  "reference/R3dux.Blazor.Router.Actions.RouterCancelAction.html": {
    "href": "reference/R3dux.Blazor.Router.Actions.RouterCancelAction.html",
    "title": "Class RouterCancelAction | R3dux Documentation",
    "keywords": "Class RouterCancelAction An action dispatched when the router cancels navigation. Inheritance object Fsa RouterCancelAction Implements IKeyedAction IAction IEquatable<Fsa> IEquatable<RouterCancelAction> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor.Router.Actions Assembly: R3dux.Blazor.dll Syntax public sealed record RouterCancelAction : Fsa, IKeyedAction, IAction, IEquatable<Fsa>, IEquatable<RouterCancelAction> Properties | Edit this page View Source TypeKey Gets the type of an action identifies to the consumer the nature of the action that has occurred. Declaration public override string TypeKey { get; } Property Value Type Description string Overrides Fsa.TypeKey Implements IKeyedAction IAction IEquatable<T> IEquatable<T>"
  },
  "reference/R3dux.Blazor.Router.Actions.RouterErrorAction.html": {
    "href": "reference/R3dux.Blazor.Router.Actions.RouterErrorAction.html",
    "title": "Class RouterErrorAction | R3dux Documentation",
    "keywords": "Class RouterErrorAction An action dispatched when the router errors. Inheritance object Fsa RouterErrorAction Implements IKeyedAction IAction IEquatable<Fsa> IEquatable<RouterErrorAction> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor.Router.Actions Assembly: R3dux.Blazor.dll Syntax public sealed record RouterErrorAction : Fsa, IKeyedAction, IAction, IEquatable<Fsa>, IEquatable<RouterErrorAction> Properties | Edit this page View Source TypeKey Gets the type of an action identifies to the consumer the nature of the action that has occurred. Declaration public override string TypeKey { get; } Property Value Type Description string Overrides Fsa.TypeKey Implements IKeyedAction IAction IEquatable<T> IEquatable<T>"
  },
  "reference/R3dux.Blazor.Router.Actions.RouterNavigatedAction.html": {
    "href": "reference/R3dux.Blazor.Router.Actions.RouterNavigatedAction.html",
    "title": "Class RouterNavigatedAction | R3dux Documentation",
    "keywords": "Class RouterNavigatedAction An action dispatched after navigation has ended and new route is active. Inheritance object Fsa RouterNavigatedAction Implements IKeyedAction IAction IEquatable<Fsa> IEquatable<RouterNavigatedAction> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor.Router.Actions Assembly: R3dux.Blazor.dll Syntax public sealed record RouterNavigatedAction : Fsa, IKeyedAction, IAction, IEquatable<Fsa>, IEquatable<RouterNavigatedAction> Properties | Edit this page View Source TypeKey Gets the type of an action identifies to the consumer the nature of the action that has occurred. Declaration public override string TypeKey { get; } Property Value Type Description string Overrides Fsa.TypeKey Implements IKeyedAction IAction IEquatable<T> IEquatable<T>"
  },
  "reference/R3dux.Blazor.Router.Actions.RouterNavigationAction.html": {
    "href": "reference/R3dux.Blazor.Router.Actions.RouterNavigationAction.html",
    "title": "Class RouterNavigationAction | R3dux Documentation",
    "keywords": "Class RouterNavigationAction An action dispatched when the router navigates. Inheritance object Fsa RouterNavigationAction Implements IKeyedAction IAction IEquatable<Fsa> IEquatable<RouterNavigationAction> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor.Router.Actions Assembly: R3dux.Blazor.dll Syntax public sealed record RouterNavigationAction : Fsa, IKeyedAction, IAction, IEquatable<Fsa>, IEquatable<RouterNavigationAction> Properties | Edit this page View Source TypeKey Gets the type of an action identifies to the consumer the nature of the action that has occurred. Declaration public override string TypeKey { get; } Property Value Type Description string Overrides Fsa.TypeKey Implements IKeyedAction IAction IEquatable<T> IEquatable<T>"
  },
  "reference/R3dux.Blazor.Router.Actions.RouterRequestAction.ActionPayload.html": {
    "href": "reference/R3dux.Blazor.Router.Actions.RouterRequestAction.ActionPayload.html",
    "title": "Class RouterRequestAction.ActionPayload | R3dux Documentation",
    "keywords": "Class RouterRequestAction.ActionPayload The payload for the RouterRequestAction. Inheritance object RouterRequestAction.ActionPayload Implements IEquatable<RouterRequestAction.ActionPayload> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor.Router.Actions Assembly: R3dux.Blazor.dll Syntax public sealed record RouterRequestAction.ActionPayload : IEquatable<RouterRequestAction.ActionPayload> Constructors | Edit this page View Source ActionPayload(object, object) The payload for the RouterRequestAction. Declaration public ActionPayload(object RouterState, object Event) Parameters Type Name Description object RouterState The current router state. object Event The event that triggered the navigation. Properties | Edit this page View Source Event The event that triggered the navigation. Declaration public object Event { get; init; } Property Value Type Description object | Edit this page View Source RouterState The current router state. Declaration public object RouterState { get; init; } Property Value Type Description object Implements IEquatable<T>"
  },
  "reference/R3dux.Blazor.Router.Actions.RouterRequestAction.html": {
    "href": "reference/R3dux.Blazor.Router.Actions.RouterRequestAction.html",
    "title": "Class RouterRequestAction | R3dux Documentation",
    "keywords": "Class RouterRequestAction An action dispatched when a router navigation request is fired. Inheritance object Fsa Fsa<RouterRequestAction.ActionPayload> RouterRequestAction Implements IKeyedAction IAction IEquatable<Fsa> IFsaPayload<RouterRequestAction.ActionPayload> IEquatable<Fsa<RouterRequestAction.ActionPayload>> IEquatable<RouterRequestAction> Inherited Members Fsa<RouterRequestAction.ActionPayload>.Payload object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor.Router.Actions Assembly: R3dux.Blazor.dll Syntax public sealed record RouterRequestAction : Fsa<RouterRequestAction.ActionPayload>, IKeyedAction, IAction, IEquatable<Fsa>, IFsaPayload<RouterRequestAction.ActionPayload>, IEquatable<Fsa<RouterRequestAction.ActionPayload>>, IEquatable<RouterRequestAction> Constructors | Edit this page View Source RouterRequestAction(ActionPayload) An action dispatched when a router navigation request is fired. Declaration public RouterRequestAction(RouterRequestAction.ActionPayload Payload) Parameters Type Name Description RouterRequestAction.ActionPayload Payload Properties | Edit this page View Source TypeKey Gets the type of an action identifies to the consumer the nature of the action that has occurred. Declaration public override string TypeKey { get; } Property Value Type Description string Overrides Fsa.TypeKey Implements IKeyedAction IAction IEquatable<T> IFsaPayload<TPayload> IEquatable<T> IEquatable<T>"
  },
  "reference/R3dux.Blazor.Router.Actions.html": {
    "href": "reference/R3dux.Blazor.Router.Actions.html",
    "title": "Namespace R3dux.Blazor.Router.Actions | R3dux Documentation",
    "keywords": "Namespace R3dux.Blazor.Router.Actions Classes RouterCancelAction An action dispatched when the router cancels navigation. RouterErrorAction An action dispatched when the router errors. RouterNavigatedAction An action dispatched after navigation has ended and new route is active. RouterNavigationAction An action dispatched when the router navigates. RouterRequestAction An action dispatched when a router navigation request is fired. RouterRequestAction.ActionPayload The payload for the RouterRequestAction."
  },
  "reference/R3dux.Blazor.Router.RouterReducers.html": {
    "href": "reference/R3dux.Blazor.Router.RouterReducers.html",
    "title": "Class RouterReducers | R3dux Documentation",
    "keywords": "Class RouterReducers The router store reducers. Inheritance object RouterReducers Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor.Router Assembly: R3dux.Blazor.dll Syntax public class RouterReducers"
  },
  "reference/R3dux.Blazor.Router.RouterStoreState.html": {
    "href": "reference/R3dux.Blazor.Router.RouterStoreState.html",
    "title": "Class RouterStoreState | R3dux Documentation",
    "keywords": "Class RouterStoreState The state of the router store. Inheritance object RouterStoreState Implements IEquatable<RouterStoreState> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Blazor.Router Assembly: R3dux.Blazor.dll Syntax public record RouterStoreState : IEquatable<RouterStoreState> Properties | Edit this page View Source Url Gets or init the current route. Declaration public required Uri Url { get; init; } Property Value Type Description Uri Implements IEquatable<T>"
  },
  "reference/R3dux.Blazor.Router.html": {
    "href": "reference/R3dux.Blazor.Router.html",
    "title": "Namespace R3dux.Blazor.Router | R3dux Documentation",
    "keywords": "Namespace R3dux.Blazor.Router Classes RouterReducers The router store reducers. RouterStoreState The state of the router store."
  },
  "reference/R3dux.Blazor.html": {
    "href": "reference/R3dux.Blazor.html",
    "title": "Namespace R3dux.Blazor | R3dux Documentation",
    "keywords": "Namespace R3dux.Blazor Classes DependencyInjections Extension methods for adding R3dux services to the dependency injection container. R3duxComponent<TState> A base component class for R3dux components that manages state and dispatches actions. R3duxLayout<TState> A base layout class for R3dux components that manages state and dispatches actions."
  },
  "reference/R3dux.DependencyInjections.html": {
    "href": "reference/R3dux.DependencyInjections.html",
    "title": "Class DependencyInjections | R3dux Documentation",
    "keywords": "Class DependencyInjections Extension methods for adding R3dux services to the dependency injection container. Inheritance object DependencyInjections Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public static class DependencyInjections Methods | Edit this page View Source AddR3duxCore(IServiceCollection, R3duxOptions) Core method to add R3dux services to the specified IServiceCollection. This method registers the BlazorR3 services, dispatcher, slices, and effects. Declaration public static IServiceCollection AddR3duxCore(this IServiceCollection services, R3duxOptions options) Parameters Type Name Description IServiceCollection services The IServiceCollection to add the services to. R3duxOptions options The configured R3duxOptions. Returns Type Description IServiceCollection The IServiceCollection so that additional calls can be chained."
  },
  "reference/R3dux.Dispatcher.html": {
    "href": "reference/R3dux.Dispatcher.html",
    "title": "Class Dispatcher | R3dux Documentation",
    "keywords": "Class Dispatcher A dispatcher that queues and dispatches actions, providing an observable stream of dispatched actions. Inheritance object Dispatcher Implements IDispatcher IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public sealed class Dispatcher : IDispatcher, IDisposable Properties | Edit this page View Source ActionStream Gets an observable stream of dispatched actions. Declaration public Observable<IAction> ActionStream { get; } Property Value Type Description Observable<IAction> Methods | Edit this page View Source Dispatch(IAction) Dispatches the specified action. Declaration public void Dispatch(IAction action) Parameters Type Name Description IAction action The action to dispatch. Exceptions Type Condition ArgumentNullException Thrown when the action is null. ObjectDisposedException Thrown when the dispatcher has been disposed. | Edit this page View Source Dispose() Releases all resources used by the Dispatcher class. Declaration public void Dispose() Implements IDispatcher IDisposable"
  },
  "reference/R3dux.Effect.html": {
    "href": "reference/R3dux.Effect.html",
    "title": "Class Effect | R3dux Documentation",
    "keywords": "Class Effect Supports all classes in the .NET class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all .NET classes; it is the root of the type hierarchy. Inheritance object Effect Implements IEffect Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public abstract class Effect : IEffect Properties | Edit this page View Source TimeProvider Gets or init the time provider used to provide the current time. Declaration public TimeProvider TimeProvider { get; init; } Property Value Type Description TimeProvider Methods | Edit this page View Source GetAssemblyName() Gets the assembly-qualified name of the effect. Declaration public string GetAssemblyName() Returns Type Description string The assembly-qualified name of the effect. | Edit this page View Source GetKey() Gets the key that identifies the effect. Declaration public string GetKey() Returns Type Description string The key that identifies the effect. | Edit this page View Source Handle(Observable<IAction>, Observable<IRootState>) Handles a stream of actions and produces a stream of resulting actions. Declaration public virtual Observable<IAction> Handle(Observable<IAction> actions, Observable<IRootState> rootState) Parameters Type Name Description Observable<IAction> actions The source observable sequence of actions. Observable<IRootState> rootState The source observable sequence of the root state. Returns Type Description Observable<IAction> An observable sequence of resulting actions. Implements IEffect"
  },
  "reference/R3dux.Extensions.FluxStandardActions.ActionMeta.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.ActionMeta.html",
    "title": "Class ActionMeta | R3dux Documentation",
    "keywords": "Class ActionMeta Represents the metadata properties of an action. Inheritance object ActionMeta Implements IEquatable<ActionMeta> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public sealed record ActionMeta : IEquatable<ActionMeta> Constructors | Edit this page View Source ActionMeta(DateTime) Represents the metadata properties of an action. Declaration public ActionMeta(DateTime TimeStamp) Parameters Type Name Description DateTime TimeStamp The time the action was created. Properties | Edit this page View Source TimeStamp The time the action was created. Declaration public DateTime TimeStamp { get; init; } Property Value Type Description DateTime Methods | Edit this page View Source Create() Creates a new instance of the ActionMeta record. Declaration public static ActionMeta Create() Returns Type Description ActionMeta A new instance of the ActionMeta record. Implements IEquatable<T>"
  },
  "reference/R3dux.Extensions.FluxStandardActions.Fsa-1.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.Fsa-1.html",
    "title": "Class Fsa<TPayload> | R3dux Documentation",
    "keywords": "Class Fsa<TPayload> A Flux Standard action with a generic payload type. Inheritance object Fsa Fsa<TPayload> RouterRequestAction Fsa<TPayload, TMeta> Implements IKeyedAction IAction IEquatable<Fsa> IFsaPayload<TPayload> IEquatable<Fsa<TPayload>> Inherited Members Fsa.TypeKey object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public abstract record Fsa<TPayload> : Fsa, IKeyedAction, IAction, IEquatable<Fsa>, IFsaPayload<TPayload>, IEquatable<Fsa<TPayload>> Type Parameters Name Description TPayload The type of the payload. Constructors | Edit this page View Source Fsa(TPayload) A Flux Standard action with a generic payload type. Declaration protected Fsa(TPayload Payload) Parameters Type Name Description TPayload Payload The payload of the action. Properties | Edit this page View Source Payload Gets the optional payload property MAY be any type of value. Declaration public TPayload Payload { get; init; } Property Value Type Description TPayload Implements IKeyedAction IAction IEquatable<T> IFsaPayload<TPayload> IEquatable<T>"
  },
  "reference/R3dux.Extensions.FluxStandardActions.Fsa-2.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.Fsa-2.html",
    "title": "Class Fsa<TPayload, TMeta> | R3dux Documentation",
    "keywords": "Class Fsa<TPayload, TMeta> A Flux Standard action with a generic payload and metadata type. Inheritance object Fsa Fsa<TPayload> Fsa<TPayload, TMeta> Implements IKeyedAction IAction IEquatable<Fsa> IFsaPayload<TPayload> IEquatable<Fsa<TPayload>> IFsaMeta<TMeta> IEquatable<Fsa<TPayload, TMeta>> Inherited Members Fsa<TPayload>.Payload Fsa.TypeKey object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public abstract record Fsa<TPayload, TMeta> : Fsa<TPayload>, IKeyedAction, IAction, IEquatable<Fsa>, IFsaPayload<TPayload>, IEquatable<Fsa<TPayload>>, IFsaMeta<TMeta>, IEquatable<Fsa<TPayload, TMeta>> Type Parameters Name Description TPayload The type of the payload. TMeta The type of the metadata. Constructors | Edit this page View Source Fsa(TPayload, TMeta) A Flux Standard action with a generic payload and metadata type. Declaration protected Fsa(TPayload Payload, TMeta Meta) Parameters Type Name Description TPayload Payload The payload of the action. TMeta Meta The metadata of the action. Properties | Edit this page View Source Meta Gets the optional meta property MAY be any type of value. Declaration public TMeta Meta { get; init; } Property Value Type Description TMeta Implements IKeyedAction IAction IEquatable<T> IFsaPayload<TPayload> IEquatable<T> IFsaMeta<TMeta> IEquatable<T>"
  },
  "reference/R3dux.Extensions.FluxStandardActions.Fsa.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.Fsa.html",
    "title": "Class Fsa | R3dux Documentation",
    "keywords": "Class Fsa A Flux Standard action without payload or metadata properties. Inheritance object Fsa RouterCancelAction RouterErrorAction RouterNavigatedAction RouterNavigationAction FsaError FsaMeta<TMeta> Fsa<TPayload> Implements IKeyedAction IAction IEquatable<Fsa> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public abstract record Fsa : IKeyedAction, IAction, IEquatable<Fsa> Properties | Edit this page View Source TypeKey Gets the type of an action identifies to the consumer the nature of the action that has occurred. Declaration public abstract string TypeKey { get; } Property Value Type Description string Implements IKeyedAction IAction IEquatable<T>"
  },
  "reference/R3dux.Extensions.FluxStandardActions.FsaError-1.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.FsaError-1.html",
    "title": "Class FsaError<TMeta> | R3dux Documentation",
    "keywords": "Class FsaError<TMeta> A Flux Standard action with an error property and metadata properties. Inheritance object Fsa FsaError FsaError<TMeta> Implements IKeyedAction IAction IEquatable<Fsa> IFsaPayload<Exception> IEquatable<FsaError> IFsaMeta<TMeta> IEquatable<FsaError<TMeta>> Inherited Members FsaError.Payload FsaError.Error Fsa.TypeKey object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public abstract record FsaError<TMeta> : FsaError, IKeyedAction, IAction, IEquatable<Fsa>, IFsaPayload<Exception>, IEquatable<FsaError>, IFsaMeta<TMeta>, IEquatable<FsaError<TMeta>> Type Parameters Name Description TMeta The type of the metadata. Constructors | Edit this page View Source FsaError(Exception, TMeta) A Flux Standard action with an error property and metadata properties. Declaration protected FsaError(Exception Payload, TMeta Meta) Parameters Type Name Description Exception Payload TMeta Meta Properties | Edit this page View Source Meta Gets the optional meta property MAY be any type of value. Declaration public TMeta Meta { get; init; } Property Value Type Description TMeta Implements IKeyedAction IAction IEquatable<T> IFsaPayload<TPayload> IEquatable<T> IFsaMeta<TMeta> IEquatable<T>"
  },
  "reference/R3dux.Extensions.FluxStandardActions.FsaError.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.FsaError.html",
    "title": "Class FsaError | R3dux Documentation",
    "keywords": "Class FsaError A Flux Standard action with an error property. Inheritance object Fsa FsaError FsaError<TMeta> Implements IKeyedAction IAction IEquatable<Fsa> IFsaPayload<Exception> IEquatable<FsaError> Inherited Members Fsa.TypeKey object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public abstract record FsaError : Fsa, IKeyedAction, IAction, IEquatable<Fsa>, IFsaPayload<Exception>, IEquatable<FsaError> Constructors | Edit this page View Source FsaError(Exception) A Flux Standard action with an error property. Declaration protected FsaError(Exception Payload) Parameters Type Name Description Exception Payload The error payload of the action. Properties | Edit this page View Source Error Gets a value indicating whether the action is an error. Declaration public static bool Error { get; } Property Value Type Description bool | Edit this page View Source Payload Gets the error payload of the action. Declaration public Exception Payload { get; init; } Property Value Type Description Exception Implements IKeyedAction IAction IEquatable<T> IFsaPayload<TPayload> IEquatable<T>"
  },
  "reference/R3dux.Extensions.FluxStandardActions.FsaMeta-1.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.FsaMeta-1.html",
    "title": "Class FsaMeta<TMeta> | R3dux Documentation",
    "keywords": "Class FsaMeta<TMeta> A Flux Standard action with metadata properties. Inheritance object Fsa FsaMeta<TMeta> Implements IKeyedAction IAction IEquatable<Fsa> IFsaMeta<TMeta> IEquatable<FsaMeta<TMeta>> Inherited Members Fsa.TypeKey object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public abstract record FsaMeta<TMeta> : Fsa, IKeyedAction, IAction, IEquatable<Fsa>, IFsaMeta<TMeta>, IEquatable<FsaMeta<TMeta>> Type Parameters Name Description TMeta Constructors | Edit this page View Source FsaMeta(TMeta) A Flux Standard action with metadata properties. Declaration protected FsaMeta(TMeta Meta) Parameters Type Name Description TMeta Meta The metadata of the action. Properties | Edit this page View Source Meta Gets the optional meta property MAY be any type of value. Declaration public TMeta Meta { get; init; } Property Value Type Description TMeta Implements IKeyedAction IAction IEquatable<T> IFsaMeta<TMeta> IEquatable<T>"
  },
  "reference/R3dux.Extensions.FluxStandardActions.IFsaMeta-1.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.IFsaMeta-1.html",
    "title": "Interface IFsaMeta<TMeta> | R3dux Documentation",
    "keywords": "Interface IFsaMeta<TMeta> Represents an action with a metadata property. Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public interface IFsaMeta<TMeta> Type Parameters Name Description TMeta The type of the metadata. Properties | Edit this page View Source Meta Gets the optional meta property MAY be any type of value. Declaration TMeta Meta { get; init; } Property Value Type Description TMeta"
  },
  "reference/R3dux.Extensions.FluxStandardActions.IFsaPayload-1.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.IFsaPayload-1.html",
    "title": "Interface IFsaPayload<TPayload> | R3dux Documentation",
    "keywords": "Interface IFsaPayload<TPayload> Represents an action with a payload property. Namespace: R3dux.Extensions.FluxStandardActions Assembly: R3dux.FluxStandardActions.dll Syntax public interface IFsaPayload<TPayload> Type Parameters Name Description TPayload The type of the payload. Properties | Edit this page View Source Payload Gets the optional payload property MAY be any type of value. Declaration TPayload Payload { get; init; } Property Value Type Description TPayload"
  },
  "reference/R3dux.Extensions.FluxStandardActions.html": {
    "href": "reference/R3dux.Extensions.FluxStandardActions.html",
    "title": "Namespace R3dux.Extensions.FluxStandardActions | R3dux Documentation",
    "keywords": "Namespace R3dux.Extensions.FluxStandardActions Classes ActionMeta Represents the metadata properties of an action. Fsa A Flux Standard action without payload or metadata properties. FsaError A Flux Standard action with an error property. FsaError<TMeta> A Flux Standard action with an error property and metadata properties. FsaMeta<TMeta> A Flux Standard action with metadata properties. Fsa<TPayload> A Flux Standard action with a generic payload type. Fsa<TPayload, TMeta> A Flux Standard action with a generic payload and metadata type. Interfaces IFsaMeta<TMeta> Represents an action with a metadata property. IFsaPayload<TPayload> Represents an action with a payload property."
  },
  "reference/R3dux.Extensions.Normalization.IEntity-1.html": {
    "href": "reference/R3dux.Extensions.Normalization.IEntity-1.html",
    "title": "Interface IEntity<TKey> | R3dux Documentation",
    "keywords": "Interface IEntity<TKey> Represents an entity with an identifier. Namespace: R3dux.Extensions.Normalization Assembly: R3dux.Normalization.dll Syntax public interface IEntity<out TKey> where TKey : notnull Type Parameters Name Description TKey The type of the entity's key. Properties | Edit this page View Source Id Gets the identifier of the entity. Declaration TKey Id { get; } Property Value Type Description TKey"
  },
  "reference/R3dux.Extensions.Normalization.INormalizedStateCollectionMethods-3.html": {
    "href": "reference/R3dux.Extensions.Normalization.INormalizedStateCollectionMethods-3.html",
    "title": "Interface INormalizedStateCollectionMethods<TKey, TEntity, TState> | R3dux Documentation",
    "keywords": "Interface INormalizedStateCollectionMethods<TKey, TEntity, TState> Defines methods for managing a collection of entities within a normalized state. Namespace: R3dux.Extensions.Normalization Assembly: R3dux.Normalization.dll Syntax public interface INormalizedStateCollectionMethods<in TKey, TEntity, out TState> where TKey : IEquatable<in TKey> where TEntity : IEntity<in TKey> where TState : NormalizedState<in TKey, TEntity, out TState>, new() Type Parameters Name Description TKey The type of the entity key. TEntity The type of the entity. TState The type of the state. Methods | Edit this page View Source AddMany(IEnumerable<TEntity>) Adds multiple entities to the collection. Declaration TState AddMany(IEnumerable<TEntity> entities) Parameters Type Name Description IEnumerable<TEntity> entities The entities to add. Returns Type Description TState The new state with the entities added. Exceptions Type Condition ArgumentNullException The entities collection must not be null. | Edit this page View Source AddOne(TEntity) Adds one entity to the collection. Declaration TState AddOne(TEntity entity) Parameters Type Name Description TEntity entity The entity to add. Returns Type Description TState The new state with the entity added. Exceptions Type Condition ArgumentNullException The entity must not be null. | Edit this page View Source Map(Func<TEntity, TEntity>) Updates multiple entities in the collection by defining a map function. Declaration TState Map(Func<TEntity, TEntity> map) Parameters Type Name Description Func<TEntity, TEntity> map The map function to apply to the entities. Returns Type Description TState The new state with the entities mapped. Exceptions Type Condition ArgumentNullException The map function must not be null. | Edit this page View Source MapOne(TKey, Func<TEntity, TEntity>) Updates one entity in the collection by defining a map function. Declaration TState MapOne(TKey key, Func<TEntity, TEntity> map) Parameters Type Name Description TKey key The key of the entity to map. Func<TEntity, TEntity> map The map function to apply to the entity. Returns Type Description TState The new state with the entity mapped. Exceptions Type Condition ArgumentNullException The key and map function must not be null. | Edit this page View Source RemoveAll() Clears the entity collection. Declaration TState RemoveAll() Returns Type Description TState The new state with the collection cleared. | Edit this page View Source RemoveMany(IEnumerable<TKey>) Removes multiple entities from the collection by id. Declaration TState RemoveMany(IEnumerable<in TKey> keys) Parameters Type Name Description IEnumerable<TKey> keys The keys of the entities to remove. Returns Type Description TState The new state with the entities removed. Exceptions Type Condition ArgumentNullException The keys collection must not be null. | Edit this page View Source RemoveMany(Func<TEntity, bool>) Removes multiple entities from the collection by a predicate. Declaration TState RemoveMany(Func<TEntity, bool> predicate) Parameters Type Name Description Func<TEntity, bool> predicate The predicate to filter entities to remove. Returns Type Description TState The new state with the entities removed. Exceptions Type Condition ArgumentNullException The predicate must not be null. | Edit this page View Source RemoveOne(TKey) Removes one entity from the collection. Declaration TState RemoveOne(TKey key) Parameters Type Name Description TKey key The key of the entity to remove. Returns Type Description TState The new state with the entity removed. Exceptions Type Condition ArgumentNullException The key must not be null. | Edit this page View Source SetAll(IEnumerable<TEntity>) Replaces the current collection with the provided collection. Declaration TState SetAll(IEnumerable<TEntity> entities) Parameters Type Name Description IEnumerable<TEntity> entities The entities to set. Returns Type Description TState The new state with the entities set. Exceptions Type Condition ArgumentNullException The entities collection must not be null. | Edit this page View Source SetMany(IEnumerable<TEntity>) Adds or replaces multiple entities in the collection. Declaration TState SetMany(IEnumerable<TEntity> entities) Parameters Type Name Description IEnumerable<TEntity> entities The entities to set. Returns Type Description TState The new state with the entities set. Exceptions Type Condition ArgumentNullException The entities collection must not be null. | Edit this page View Source SetOne(TEntity) Adds or replaces one entity in the collection. Declaration TState SetOne(TEntity entity) Parameters Type Name Description TEntity entity The entity to set. Returns Type Description TState The new state with the entity set. Exceptions Type Condition ArgumentNullException The entity must not be null. | Edit this page View Source UpdateMany(IEnumerable<TKey>, Action<TEntity>) Updates multiple entities in the collection. Supports partial updates. Declaration TState UpdateMany(IEnumerable<in TKey> keys, Action<TEntity> update) Parameters Type Name Description IEnumerable<TKey> keys The keys of the entities to update. Action<TEntity> update The update action to apply to the entities. Returns Type Description TState The new state with the entities updated. Exceptions Type Condition ArgumentNullException The keys collection and update action must not be null. | Edit this page View Source UpdateMany(IEnumerable<TKey>, Func<TEntity, TEntity>) Updates multiple entities in the collection. Supports partial updates. Declaration TState UpdateMany(IEnumerable<in TKey> keys, Func<TEntity, TEntity> update) Parameters Type Name Description IEnumerable<TKey> keys The keys of the entities to update. Func<TEntity, TEntity> update The update action to apply to the entities. Returns Type Description TState The new state with the entities updated. Exceptions Type Condition ArgumentNullException The keys collection and update action must not be null. | Edit this page View Source UpdateOne(TKey, Action<TEntity>) Updates one entity in the collection. Supports partial updates. Declaration TState UpdateOne(TKey key, Action<TEntity> update) Parameters Type Name Description TKey key The key of the entity to update. Action<TEntity> update The update action to apply to the entity. Returns Type Description TState The new state with the entity updated. Exceptions Type Condition ArgumentNullException The key and update action must not be null. | Edit this page View Source UpdateOne(TKey, Func<TEntity, TEntity>) Updates one entity in the collection. Supports partial updates. Declaration TState UpdateOne(TKey key, Func<TEntity, TEntity> update) Parameters Type Name Description TKey key The key of the entity to update. Func<TEntity, TEntity> update The update function to apply to the entity. Returns Type Description TState The new state with the entity updated. Exceptions Type Condition ArgumentNullException The key and update action must not be null. | Edit this page View Source UpsertMany(IEnumerable<TEntity>) Adds or updates multiple entities in the collection. Declaration TState UpsertMany(IEnumerable<TEntity> entities) Parameters Type Name Description IEnumerable<TEntity> entities The entities to upsert. Returns Type Description TState The new state with the entities upserted. Exceptions Type Condition ArgumentNullException The entities collection must not be null. | Edit this page View Source UpsertOne(TEntity) Adds or updates one entity in the collection. Declaration TState UpsertOne(TEntity entity) Parameters Type Name Description TEntity entity The entity to upsert. Returns Type Description TState The new state with the entity upserted. Exceptions Type Condition ArgumentNullException The entity must not be null."
  },
  "reference/R3dux.Extensions.Normalization.MergeStrategy.html": {
    "href": "reference/R3dux.Extensions.Normalization.MergeStrategy.html",
    "title": "Enum MergeStrategy | R3dux Documentation",
    "keywords": "Enum MergeStrategy Defines strategies for merging entities into the state. Namespace: R3dux.Extensions.Normalization Assembly: R3dux.Normalization.dll Syntax public enum MergeStrategy Fields Name Description FailIfDuplicate Fail if a duplicate entity is found during the merge. Overwrite Overwrite existing entities with the same key during the merge."
  },
  "reference/R3dux.Extensions.Normalization.NormalizedState-3.html": {
    "href": "reference/R3dux.Extensions.Normalization.NormalizedState-3.html",
    "title": "Class NormalizedState<TKey, TEntity, TState> | R3dux Documentation",
    "keywords": "Class NormalizedState<TKey, TEntity, TState> Represents a normalized state for collections. Inheritance object NormalizedState<TKey, TEntity, TState> Implements INormalizedStateCollectionMethods<TKey, TEntity, TState> IEquatable<NormalizedState<TKey, TEntity, TState>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.Normalization Assembly: R3dux.Normalization.dll Syntax public abstract record NormalizedState<TKey, TEntity, TState> : INormalizedStateCollectionMethods<TKey, TEntity, TState>, IEquatable<NormalizedState<TKey, TEntity, TState>> where TKey : IEquatable<TKey> where TEntity : IEntity<TKey> where TState : NormalizedState<TKey, TEntity, TState>, new() Type Parameters Name Description TKey The type of the entity key. TEntity The type of the entity value. TState The type of the state. Properties | Edit this page View Source AllIds Gets the list of entity IDs. Declaration public ImmutableList<TKey> AllIds { get; } Property Value Type Description ImmutableList<TKey> | Edit this page View Source ById Gets or init the dictionary of entities. Declaration public ImmutableDictionary<TKey, TEntity> ById { get; init; } Property Value Type Description ImmutableDictionary<TKey, TEntity> | Edit this page View Source this[TKey] Indexer to get an entity by its key. Declaration public TEntity this[TKey key] { get; } Parameters Type Name Description TKey key The key of the entity. Property Value Type Description TEntity The entity associated with the specified key. Methods | Edit this page View Source AddMany(IEnumerable<TEntity>) Adds multiple entities to the collection. Declaration public TState AddMany(IEnumerable<TEntity> entities) Parameters Type Name Description IEnumerable<TEntity> entities The entities to add. Returns Type Description TState The new state with the entities added. Exceptions Type Condition ArgumentNullException The entities collection must not be null. | Edit this page View Source AddOne(TEntity) Adds one entity to the collection. Declaration public TState AddOne(TEntity entity) Parameters Type Name Description TEntity entity The entity to add. Returns Type Description TState The new state with the entity added. Exceptions Type Condition ArgumentNullException The entity must not be null. | Edit this page View Source ContainsKey(TKey) Checks if an entity with the specified key exists in the state. Declaration public bool ContainsKey(TKey key) Parameters Type Name Description TKey key The key of the entity. Returns Type Description bool true if the entity exists; otherwise, false. | Edit this page View Source Create(ImmutableList<TEntity>) Creates a new state with the specified entities. Declaration public static TState Create(ImmutableList<TEntity> entities) Parameters Type Name Description ImmutableList<TEntity> entities The entities to create the state with. Returns Type Description TState A new state with the entities. | Edit this page View Source GetByKey(TKey) Gets an entity by its key. Declaration public TEntity GetByKey(TKey key) Parameters Type Name Description TKey key The key of the entity. Returns Type Description TEntity The entity if found; otherwise, null. Exceptions Type Condition R3duxException The entity does not exist. | Edit this page View Source Map(Func<TEntity, TEntity>) Updates multiple entities in the collection by defining a map function. Declaration public TState Map(Func<TEntity, TEntity> map) Parameters Type Name Description Func<TEntity, TEntity> map The map function to apply to the entities. Returns Type Description TState The new state with the entities mapped. Exceptions Type Condition ArgumentNullException The map function must not be null. | Edit this page View Source MapOne(TKey, Func<TEntity, TEntity>) Updates one entity in the collection by defining a map function. Declaration public TState MapOne(TKey key, Func<TEntity, TEntity> map) Parameters Type Name Description TKey key The key of the entity to map. Func<TEntity, TEntity> map The map function to apply to the entity. Returns Type Description TState The new state with the entity mapped. Exceptions Type Condition ArgumentNullException The key and map function must not be null. | Edit this page View Source Merge(ImmutableDictionary<TKey, TEntity>, MergeStrategy) Merges the specified entities into the state using the provided merge strategy. Declaration public TState Merge(ImmutableDictionary<TKey, TEntity> entities, MergeStrategy strategy = MergeStrategy.FailIfDuplicate) Parameters Type Name Description ImmutableDictionary<TKey, TEntity> entities The entities to merge into the state. MergeStrategy strategy The strategy to use when merging entities. Returns Type Description TState A new state with the entities merged. Exceptions Type Condition R3duxException The state must be of type TState. | Edit this page View Source RemoveAll() Clears the entity collection. Declaration public TState RemoveAll() Returns Type Description TState The new state with the collection cleared. | Edit this page View Source RemoveMany(IEnumerable<TKey>) Removes multiple entities from the collection by id. Declaration public TState RemoveMany(IEnumerable<TKey> keys) Parameters Type Name Description IEnumerable<TKey> keys The keys of the entities to remove. Returns Type Description TState The new state with the entities removed. Exceptions Type Condition ArgumentNullException The keys collection must not be null. | Edit this page View Source RemoveMany(Func<TEntity, bool>) Removes multiple entities from the collection by a predicate. Declaration public TState RemoveMany(Func<TEntity, bool> predicate) Parameters Type Name Description Func<TEntity, bool> predicate The predicate to filter entities to remove. Returns Type Description TState The new state with the entities removed. Exceptions Type Condition ArgumentNullException The predicate must not be null. | Edit this page View Source RemoveOne(TKey) Removes one entity from the collection. Declaration public TState RemoveOne(TKey key) Parameters Type Name Description TKey key The key of the entity to remove. Returns Type Description TState The new state with the entity removed. Exceptions Type Condition ArgumentNullException The key must not be null. | Edit this page View Source SelectImmutableList() Selects entities. Declaration public ImmutableList<TEntity> SelectImmutableList() Returns Type Description ImmutableList<TEntity> An immutable list of entities. | Edit this page View Source SelectImmutableList(Func<TEntity, bool>) Selects entities based on a predicate. Declaration public ImmutableList<TEntity> SelectImmutableList(Func<TEntity, bool> predicate) Parameters Type Name Description Func<TEntity, bool> predicate The predicate to filter entities. Returns Type Description ImmutableList<TEntity> An immutable list of entities that match the predicate. | Edit this page View Source SetAll(IEnumerable<TEntity>) Replaces the current collection with the provided collection. Declaration public TState SetAll(IEnumerable<TEntity> entities) Parameters Type Name Description IEnumerable<TEntity> entities The entities to set. Returns Type Description TState The new state with the entities set. Exceptions Type Condition ArgumentNullException The entities collection must not be null. | Edit this page View Source SetMany(IEnumerable<TEntity>) Adds or replaces multiple entities in the collection. Declaration public TState SetMany(IEnumerable<TEntity> entities) Parameters Type Name Description IEnumerable<TEntity> entities The entities to set. Returns Type Description TState The new state with the entities set. Exceptions Type Condition ArgumentNullException The entities collection must not be null. | Edit this page View Source SetOne(TEntity) Adds or replaces one entity in the collection. Declaration public TState SetOne(TEntity entity) Parameters Type Name Description TEntity entity The entity to set. Returns Type Description TState The new state with the entity set. Exceptions Type Condition ArgumentNullException The entity must not be null. | Edit this page View Source UpdateMany(IEnumerable<TKey>, Action<TEntity>) Updates multiple entities in the collection. Supports partial updates. Declaration public TState UpdateMany(IEnumerable<TKey> keys, Action<TEntity> update) Parameters Type Name Description IEnumerable<TKey> keys The keys of the entities to update. Action<TEntity> update The update action to apply to the entities. Returns Type Description TState The new state with the entities updated. Exceptions Type Condition ArgumentNullException The keys collection and update action must not be null. | Edit this page View Source UpdateMany(IEnumerable<TKey>, Func<TEntity, TEntity>) Updates multiple entities in the collection. Supports partial updates. Declaration public TState UpdateMany(IEnumerable<TKey> keys, Func<TEntity, TEntity> update) Parameters Type Name Description IEnumerable<TKey> keys The keys of the entities to update. Func<TEntity, TEntity> update The update action to apply to the entities. Returns Type Description TState The new state with the entities updated. Exceptions Type Condition ArgumentNullException The keys collection and update action must not be null. | Edit this page View Source UpdateOne(TKey, Action<TEntity>) Updates one entity in the collection. Supports partial updates. Declaration public TState UpdateOne(TKey key, Action<TEntity> update) Parameters Type Name Description TKey key The key of the entity to update. Action<TEntity> update The update action to apply to the entity. Returns Type Description TState The new state with the entity updated. Exceptions Type Condition ArgumentNullException The key and update action must not be null. | Edit this page View Source UpdateOne(TKey, Func<TEntity, TEntity>) Updates one entity in the collection. Supports partial updates. Declaration public TState UpdateOne(TKey key, Func<TEntity, TEntity> update) Parameters Type Name Description TKey key The key of the entity to update. Func<TEntity, TEntity> update The update function to apply to the entity. Returns Type Description TState The new state with the entity updated. Exceptions Type Condition ArgumentNullException The key and update action must not be null. | Edit this page View Source UpsertMany(IEnumerable<TEntity>) Adds or updates multiple entities in the collection. Declaration public TState UpsertMany(IEnumerable<TEntity> entities) Parameters Type Name Description IEnumerable<TEntity> entities The entities to upsert. Returns Type Description TState The new state with the entities upserted. Exceptions Type Condition ArgumentNullException The entities collection must not be null. | Edit this page View Source UpsertOne(TEntity) Adds or updates one entity in the collection. Declaration public TState UpsertOne(TEntity entity) Parameters Type Name Description TEntity entity The entity to upsert. Returns Type Description TState The new state with the entity upserted. Exceptions Type Condition ArgumentNullException The entity must not be null. Implements INormalizedStateCollectionMethods<TKey, TEntity, TState> IEquatable<T>"
  },
  "reference/R3dux.Extensions.Normalization.html": {
    "href": "reference/R3dux.Extensions.Normalization.html",
    "title": "Namespace R3dux.Extensions.Normalization | R3dux Documentation",
    "keywords": "Namespace R3dux.Extensions.Normalization Classes NormalizedState<TKey, TEntity, TState> Represents a normalized state for collections. Interfaces IEntity<TKey> Represents an entity with an identifier. INormalizedStateCollectionMethods<TKey, TEntity, TState> Defines methods for managing a collection of entities within a normalized state. Enums MergeStrategy Defines strategies for merging entities into the state."
  },
  "reference/R3dux.Extensions.Operators.CustomOperators.html": {
    "href": "reference/R3dux.Extensions.Operators.CustomOperators.html",
    "title": "Class CustomOperators | R3dux Documentation",
    "keywords": "Class CustomOperators Provides custom operators for working with observable sequences in the R3dux application. Inheritance object CustomOperators Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.Operators Assembly: R3dux.Operators.dll Syntax public static class CustomOperators Methods | Edit this page View Source CatchAction<TSource>(Observable<TSource>, Func<Exception, TSource>) Catches exceptions in the observable sequence and replaces the exception with a specified value. Declaration public static Observable<TSource> CatchAction<TSource>(this Observable<TSource> source, Func<Exception, TSource> selector) Parameters Type Name Description Observable<TSource> source The source observable sequence. Func<Exception, TSource> selector A transform function to apply to each exception. Returns Type Description Observable<TSource> An observable sequence containing the source elements and replacing exceptions with the result of the selector function. Type Parameters Name Description TSource The type of the source elements. | Edit this page View Source InvokeService<TAction, TResult>(Observable<TAction>, Func<TAction, ValueTask<TResult>>, Func<TResult, IAction>, Func<Exception, IAction>) Invokes a service call for each element in the observable sequence, returning a sequence of actions based on the result or error. Declaration public static Observable<IAction> InvokeService<TAction, TResult>(this Observable<TAction> source, Func<TAction, ValueTask<TResult>> serviceCall, Func<TResult, IAction> successSelector, Func<Exception, IAction> errorSelector) Parameters Type Name Description Observable<TAction> source The source observable sequence. Func<TAction, ValueTask<TResult>> serviceCall A function that performs the service call. Func<TResult, IAction> successSelector A function that selects the success action based on the result. Func<Exception, IAction> errorSelector A function that selects the error action based on the exception. Returns Type Description Observable<IAction> An observable sequence of actions resulting from the service call. Type Parameters Name Description TAction The type of the source elements, which are actions to be processed. TResult The type of the result from the service call. | Edit this page View Source LogMessage<TSource>(Observable<TSource>, string) Logs a message to the console for each element in the observable sequence. Declaration public static Observable<TSource> LogMessage<TSource>(this Observable<TSource> source, string message) Parameters Type Name Description Observable<TSource> source The source observable sequence. string message The message to log to the console. Returns Type Description Observable<TSource> The source sequence with added side-effects of logging each element. Type Parameters Name Description TSource The type of the source elements. | Edit this page View Source OfType<TAction>(Observable<IAction>) Filters the observable sequence to include only elements of a specified type. Declaration public static Observable<TAction> OfType<TAction>(this Observable<IAction> source) where TAction : IAction Parameters Type Name Description Observable<IAction> source The source observable sequence. Returns Type Description Observable<TAction> An observable sequence that contains elements from the input sequence of type TAction. Type Parameters Name Description TAction The type of elements to filter. | Edit this page View Source SelectAction<TSource, TResult>(Observable<TSource>, Func<TSource, TResult>) Projects each element of an observable sequence into a new form and casts it to IAction. Declaration public static Observable<IAction> SelectAction<TSource, TResult>(this Observable<TSource> source, Func<TSource, TResult> selector) Parameters Type Name Description Observable<TSource> source The source observable sequence. Func<TSource, TResult> selector A transform function to apply to each element. Returns Type Description Observable<IAction> An observable sequence of IAction. Type Parameters Name Description TSource The type of the source elements. TResult The type of the result elements, which must implement IAction. | Edit this page View Source WithSliceState<TState, TAction>(Observable<TAction>, Observable<IRootState>, string?) Combines the observable sequence with the state of a slice and projects the result into a new form. Declaration public static Observable<StateActionPair<TState, TAction>> WithSliceState<TState, TAction>(this Observable<TAction> source, Observable<IRootState> rootStateObs, string? sliceKey = null) where TState : notnull where TAction : IAction Parameters Type Name Description Observable<TAction> source The source observable sequence. Observable<IRootState> rootStateObs The observable sequence of the root state. string sliceKey The key of the slice to select. Returns Type Description Observable<StateActionPair<TState, TAction>> An observable sequence of StateActionPair. Type Parameters Name Description TState The type of the state. TAction The type of the action."
  },
  "reference/R3dux.Extensions.Operators.ObservableExtensions.html": {
    "href": "reference/R3dux.Extensions.Operators.ObservableExtensions.html",
    "title": "Class ObservableExtensions | R3dux Documentation",
    "keywords": "Class ObservableExtensions Provides extension methods for observable sequences. Inheritance object ObservableExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.Operators Assembly: R3dux.Operators.dll Syntax public static class ObservableExtensions Methods | Edit this page View Source FirstSync<T>(Observable<T>) Returns the first element of an observable sequence synchronously. Declaration public static T FirstSync<T>(this Observable<T> observable) Parameters Type Name Description Observable<T> observable The observable sequence to return the first element of. Returns Type Description T The first element of the observable sequence. Type Parameters Name Description T The type of the elements in the sequence."
  },
  "reference/R3dux.Extensions.Operators.ReactiveSelectorExtensions.html": {
    "href": "reference/R3dux.Extensions.Operators.ReactiveSelectorExtensions.html",
    "title": "Class ReactiveSelectorExtensions | R3dux Documentation",
    "keywords": "Class ReactiveSelectorExtensions Provides extension methods for working with observables. Inheritance object ReactiveSelectorExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.Operators Assembly: R3dux.Operators.dll Syntax public static class ReactiveSelectorExtensions Methods | Edit this page View Source ConcatSelect<TInput, TOutput>(Observable<TInput>, Func<TInput, Observable<TOutput>>) Projects each element of an observable sequence into a new observable sequence and concatenates the resulting observable sequences. Declaration public static Observable<TOutput> ConcatSelect<TInput, TOutput>(this Observable<TInput> source, Func<TInput, Observable<TOutput>> selector) Parameters Type Name Description Observable<TInput> source The source observable sequence. Func<TInput, Observable<TOutput>> selector A transform function to apply to each element in the input sequence. Returns Type Description Observable<TOutput> An observable sequence whose elements are the result of invoking the transform function on each element of the source and concatenating the resulting sequences. Type Parameters Name Description TInput The type of elements in the source observable sequence. TOutput The type of elements in the projected observable sequences. | Edit this page View Source MergeSelect<TInput, TOutput>(Observable<TInput>, Func<TInput, Observable<TOutput>>) Projects each element of an observable sequence into a new observable sequence and merges the resulting observable sequences. Declaration public static Observable<TOutput> MergeSelect<TInput, TOutput>(this Observable<TInput> source, Func<TInput, Observable<TOutput>> selector) Parameters Type Name Description Observable<TInput> source The source observable sequence. Func<TInput, Observable<TOutput>> selector A transform function to apply to each element in the input sequence. Returns Type Description Observable<TOutput> An observable sequence whose elements are the result of invoking the transform function on each element of the source and merging the resulting sequences. Type Parameters Name Description TInput The type of elements in the source observable sequence. TOutput The type of elements in the projected observable sequences. | Edit this page View Source SwitchSelect<TInput, TOutput>(Observable<TInput>, Func<TInput, Observable<TOutput>>) Projects each element of an observable sequence into a new observable sequence and then switches to the latest observable sequence. Declaration public static Observable<TOutput> SwitchSelect<TInput, TOutput>(this Observable<TInput> source, Func<TInput, Observable<TOutput>> selector) Parameters Type Name Description Observable<TInput> source The source observable sequence. Func<TInput, Observable<TOutput>> selector A transform function to apply to each element in the input sequence. Returns Type Description Observable<TOutput> An observable sequence whose elements are the result of invoking the transform function on each element of the source. Type Parameters Name Description TInput The type of elements in the source observable sequence. TOutput The type of elements in the projected observable sequences."
  },
  "reference/R3dux.Extensions.Operators.StateActionPair-2.html": {
    "href": "reference/R3dux.Extensions.Operators.StateActionPair-2.html",
    "title": "Class StateActionPair<TState, TAction> | R3dux Documentation",
    "keywords": "Class StateActionPair<TState, TAction> Represents a pair of state and action. Inheritance object StateActionPair<TState, TAction> Implements IEquatable<StateActionPair<TState, TAction>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.Operators Assembly: R3dux.Operators.dll Syntax public sealed record StateActionPair<TState, TAction> : IEquatable<StateActionPair<TState, TAction>> where TAction : IAction Type Parameters Name Description TState The type of the state. TAction The type of the action, which must implement IAction. Constructors | Edit this page View Source StateActionPair(TState, TAction) Represents a pair of state and action. Declaration public StateActionPair(TState State, TAction Action) Parameters Type Name Description TState State The current state. TAction Action The action to be performed. Properties | Edit this page View Source Action The action to be performed. Declaration public TAction Action { get; init; } Property Value Type Description TAction | Edit this page View Source State The current state. Declaration public TState State { get; init; } Property Value Type Description TState Implements IEquatable<T>"
  },
  "reference/R3dux.Extensions.Operators.html": {
    "href": "reference/R3dux.Extensions.Operators.html",
    "title": "Namespace R3dux.Extensions.Operators | R3dux Documentation",
    "keywords": "Namespace R3dux.Extensions.Operators Classes CustomOperators Provides custom operators for working with observable sequences in the R3dux application. ObservableExtensions Provides extension methods for observable sequences. ReactiveSelectorExtensions Provides extension methods for working with observables. StateActionPair<TState, TAction> Represents a pair of state and action."
  },
  "reference/R3dux.Extensions.Selectors.MemoizedSelector.html": {
    "href": "reference/R3dux.Extensions.Selectors.MemoizedSelector.html",
    "title": "Class MemoizedSelector | R3dux Documentation",
    "keywords": "Class MemoizedSelector Provides memoization functionalities for selectors to minimize re-computations and allow for efficient state management. Inheritance object MemoizedSelector Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux.Extensions.Selectors Assembly: R3dux.Selectors.dll Syntax public static class MemoizedSelector Methods | Edit this page View Source Compose<TState, TIntermediate, TResult>(Func<TState, TIntermediate>, Func<TIntermediate, TResult>, params Func<TState, object>[]) Composes two selector functions into one, allowing for efficient state transformations. Declaration public static Func<TState, TResult> Compose<TState, TIntermediate, TResult>(Func<TState, TIntermediate> intermediateSelector, Func<TIntermediate, TResult> finalSelector, params Func<TState, object>[] dependencies) where TState : notnull Parameters Type Name Description Func<TState, TIntermediate> intermediateSelector The intermediate selector function. Func<TIntermediate, TResult> finalSelector The final selector function. Func<TState, object>[] dependencies The functions representing dependencies that the selectors rely on. Returns Type Description Func<TState, TResult> A memoized selector function that composes the intermediate and final selectors. Type Parameters Name Description TState The type of the state. TIntermediate The type of the intermediate result. TResult The type of the final result. | Edit this page View Source Create<TState, TResult>(Func<TState, TResult>, params Func<TState, object>[]) Creates a memoized selector that caches the results of the selector function based on the provided dependencies. Declaration public static Func<TState, TResult> Create<TState, TResult>(Func<TState, TResult> selector, params Func<TState, object>[] dependencies) where TState : notnull Parameters Type Name Description Func<TState, TResult> selector The selector function to be memoized. Func<TState, object>[] dependencies The functions representing dependencies that the selector relies on. Returns Type Description Func<TState, TResult> A memoized selector function. Type Parameters Name Description TState The type of the state. TResult The type of the result."
  },
  "reference/R3dux.Extensions.Selectors.html": {
    "href": "reference/R3dux.Extensions.Selectors.html",
    "title": "Namespace R3dux.Extensions.Selectors | R3dux Documentation",
    "keywords": "Namespace R3dux.Extensions.Selectors Classes MemoizedSelector Provides memoization functionalities for selectors to minimize re-computations and allow for efficient state management."
  },
  "reference/R3dux.LoggerProvider.html": {
    "href": "reference/R3dux.LoggerProvider.html",
    "title": "Class LoggerProvider | R3dux Documentation",
    "keywords": "Class LoggerProvider Provides a centralized mechanism to configure and obtain logger instances. Inheritance object LoggerProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public static class LoggerProvider Methods | Edit this page View Source Configure(ILoggerFactory) Configures the global logger factory used to create logger instances. Declaration public static void Configure(ILoggerFactory loggerFactory) Parameters Type Name Description ILoggerFactory loggerFactory The logger factory to use for creating logger instances. | Edit this page View Source CreateLogger<T>() Creates a logger instance for the specified type. Declaration public static ILogger<T>? CreateLogger<T>() Returns Type Description ILogger<T> A logger instance for the specified type. Type Parameters Name Description T The type for which a logger is to be created."
  },
  "reference/R3dux.ObservableSlices.html": {
    "href": "reference/R3dux.ObservableSlices.html",
    "title": "Class ObservableSlices | R3dux Documentation",
    "keywords": "Class ObservableSlices Manages a collection of observable slices and provides an observable root state. Inheritance object ObservableSlices Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public sealed class ObservableSlices : IDisposable Constructors | Edit this page View Source ObservableSlices() Initializes a new instance of the ObservableSlices class. Declaration public ObservableSlices() Properties | Edit this page View Source RootStateObservable Gets an observable that emits the root state whenever a slice is added, removed, or replaced. Declaration public ReadOnlyReactiveProperty<IRootState> RootStateObservable { get; } Property Value Type Description ReadOnlyReactiveProperty<IRootState> Methods | Edit this page View Source AddSlice(ISlice) Adds a new slice with the specified key and data. Declaration public void AddSlice(ISlice slice) Parameters Type Name Description ISlice slice The slice to add. | Edit this page View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements IDisposable"
  },
  "reference/R3dux.R3duxOptions.html": {
    "href": "reference/R3dux.R3duxOptions.html",
    "title": "Class R3duxOptions | R3dux Documentation",
    "keywords": "Class R3duxOptions Options for configuring R3dux services. Inheritance object R3duxOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public class R3duxOptions Properties | Edit this page View Source Assemblies Gets the assemblies to scan for slices and effects. Defaults to the executing assembly. Declaration public Assembly[] Assemblies { get; } Property Value Type Description Assembly[] | Edit this page View Source AssemblyNames Gets or sets the assemblies to scan for slices and effects. Declaration public string[] AssemblyNames { get; set; } Property Value Type Description string[]"
  },
  "reference/R3dux.R3duxStore.html": {
    "href": "reference/R3dux.R3duxStore.html",
    "title": "Class R3duxStore | R3dux Documentation",
    "keywords": "Class R3duxStore Represents a store that manages application state and handles actions. Inheritance object R3duxStore Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public sealed class R3duxStore : IDisposable Constructors | Edit this page View Source R3duxStore(IDispatcher) Initializes a new instance of the R3duxStore class. Declaration public R3duxStore(IDispatcher dispatcher) Parameters Type Name Description IDispatcher dispatcher The dispatcher used to dispatch actions to the store. Properties | Edit this page View Source RootStateObservable Gets an observable stream of the root state of the application. Declaration public ReadOnlyReactiveProperty<IRootState> RootStateObservable { get; } Property Value Type Description ReadOnlyReactiveProperty<IRootState> Methods | Edit this page View Source AddEffect(IEffect) Adds a single effect to the store. Declaration public void AddEffect(IEffect effect) Parameters Type Name Description IEffect effect The effect to add. | Edit this page View Source AddEffects(params IEffect[]) Adds multiple effects to the store. Declaration public void AddEffects(params IEffect[] effects) Parameters Type Name Description IEffect[] effects The effects to add. | Edit this page View Source AddSlice(ISlice) Adds a single slice to the store. Declaration public void AddSlice(ISlice slice) Parameters Type Name Description ISlice slice The slice to add. | Edit this page View Source AddSlices(params ISlice[]) Adds multiple slices to the store. Declaration public void AddSlices(params ISlice[] slices) Parameters Type Name Description ISlice[] slices The slices to add. | Edit this page View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() Implements IDisposable"
  },
  "reference/R3dux.RootState.html": {
    "href": "reference/R3dux.RootState.html",
    "title": "Class RootState | R3dux Documentation",
    "keywords": "Class RootState Represents the root state of the application, managing slice states. Inheritance object RootState Implements IRootState IEquatable<RootState> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public sealed record RootState : IRootState, IEquatable<RootState> Constructors | Edit this page View Source RootState(ImmutableSortedDictionary<string, object>) Initializes a new instance of the RootState class. Declaration public RootState(ImmutableSortedDictionary<string, object> state) Parameters Type Name Description ImmutableSortedDictionary<string, object> state The state dictionary. Methods | Edit this page View Source ContainsKey(string) Determines whether the state contains an element with the specified key. Declaration public bool ContainsKey(string key) Parameters Type Name Description string key The key to locate in the state. Returns Type Description bool true if the state contains an element with the key; otherwise, false. | Edit this page View Source GetKeys() Gets the keys of the state. Declaration public ImmutableSortedSet<string> GetKeys() Returns Type Description ImmutableSortedSet<string> The keys of the state. | Edit this page View Source GetSliceState<TState>() Gets the slice state of the specified type. Declaration public TState GetSliceState<TState>() where TState : notnull Returns Type Description TState The state of the specified type. Type Parameters Name Description TState The type of the state to select. Exceptions Type Condition R3duxException Thrown when the state is not found. | Edit this page View Source GetSliceState<TState>(string) Gets the slice state associated with the specified key. Declaration public TState GetSliceState<TState>(string key) where TState : notnull Parameters Type Name Description string key The key of the state to select. Returns Type Description TState The state associated with the specified key. Type Parameters Name Description TState The type of the state to select. Exceptions Type Condition R3duxException Thrown when the state is not of the expected type. | Edit this page View Source GetStateDictionary() Gets the underlying state dictionary for serialization purposes. Declaration public ImmutableSortedDictionary<string, object> GetStateDictionary() Returns Type Description ImmutableSortedDictionary<string, object> The state dictionary. Implements IRootState IEquatable<T>"
  },
  "reference/R3dux.RootStateSerializer.html": {
    "href": "reference/R3dux.RootStateSerializer.html",
    "title": "Class RootStateSerializer | R3dux Documentation",
    "keywords": "Class RootStateSerializer Provides methods for serializing and deserializing RootState instances. Inheritance object RootStateSerializer Implements IRootStateSerializer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public sealed class RootStateSerializer : IRootStateSerializer Methods | Edit this page View Source Deserialize(string) Deserializes a IRootState from a JSON string. Declaration public IRootState Deserialize(string json) Parameters Type Name Description string json The JSON string representation of the state. Returns Type Description IRootState A new instance of IRootState with the deserialized state. | Edit this page View Source LoadFromFile(string) Loads a IRootState from a file. Declaration public IRootState LoadFromFile(string filePath) Parameters Type Name Description string filePath The path of the file to load the state from. Returns Type Description IRootState A new instance of IRootState with the loaded state. | Edit this page View Source SaveToFile(IRootState, string) Saves the specified IRootState to a file. Declaration public void SaveToFile(IRootState rootState, string filePath) Parameters Type Name Description IRootState rootState The IRootState to save. string filePath The path of the file to save the state to. | Edit this page View Source Serialize(IRootState) Serializes the specified IRootState to a JSON string. Declaration public string Serialize(IRootState rootState) Parameters Type Name Description IRootState rootState The IRootState to serialize. Returns Type Description string The JSON string representation of the state. | Edit this page View Source Serialize(IRootState, string) Serializes the slice state associated with the specified key to a JSON string. Declaration public string Serialize(IRootState rootState, string key) Parameters Type Name Description IRootState rootState The IRootState to serialize. string key The key of the slice state to serialize. Returns Type Description string The JSON string representation of the slice state. Implements IRootStateSerializer"
  },
  "reference/R3dux.SliceReducers-1.html": {
    "href": "reference/R3dux.SliceReducers-1.html",
    "title": "Class SliceReducers<TState> | R3dux Documentation",
    "keywords": "Class SliceReducers<TState> Represents a strongly-typed state slice with state management and reducers. Inheritance object SliceReducers<TState> Implements ISlice<TState> ISlice IDisposable IEquatable<SliceReducers<TState>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public abstract record SliceReducers<TState> : ISlice<TState>, ISlice, IDisposable, IEquatable<SliceReducers<TState>> Type Parameters Name Description TState The type of the state managed by this slice. Remarks Each \"slice reducer\" is responsible for providing an initial value and calculating the updates to that slice of the state. Properties | Edit this page View Source Reducers Gets a dictionary that holds the reducers mapped by the type of action. Declaration public Dictionary<Type, Func<TState, IAction, TState>> Reducers { get; } Property Value Type Description Dictionary<Type, Func<TState, IAction, TState>> | Edit this page View Source State Gets an observable sequence that produces the state of this slice. Declaration public virtual Observable<TState> State { get; } Property Value Type Description Observable<TState> The observable sequence of the state. | Edit this page View Source StateUpdated Gets an observable sequence that produces a notification when the state is updated. Declaration public virtual Observable<Unit> StateUpdated { get; } Property Value Type Description Observable<Unit> The observable sequence of state updates. Methods | Edit this page View Source Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. Declaration public void Dispose() | Edit this page View Source Dispose(bool) Releases the unmanaged resources used by the SliceReducers<TState> and optionally releases the managed resources. Declaration protected virtual void Dispose(bool disposing) Parameters Type Name Description bool disposing If true, the method has been called directly or indirectly by a user's code. Managed and unmanaged resources can be disposed. If false, the method has been called by the runtime from inside the finalizer and only unmanaged resources can be disposed. | Edit this page View Source GetInitialState() Gets the initial state of the reducer. Declaration public virtual TState GetInitialState() Returns Type Description TState The initial state. | Edit this page View Source GetKey() Gets the unique key for this state slice. Declaration public virtual string GetKey() Returns Type Description string The unique key as a string. | Edit this page View Source GetState() Gets the current state of this slice. Declaration public virtual object GetState() Returns Type Description object The current state as an object. | Edit this page View Source GetStateType() Gets the type of the state managed by this slice. Declaration public virtual Type GetStateType() Returns Type Description Type The type of the state. | Edit this page View Source OnDispatch(IAction) Handles the dispatch of an action. Declaration public void OnDispatch(IAction action) Parameters Type Name Description IAction action The action to be dispatched. | Edit this page View Source On<TAction>(Func<TState, TState>) Maps a reducer function to a specific action type. Declaration public void On<TAction>(Func<TState, TState> reducer) Parameters Type Name Description Func<TState, TState> reducer The reducer function that takes only the state and returns a new state. Type Parameters Name Description TAction The type of the action. | Edit this page View Source On<TAction>(Func<TState, TAction, TState>) Maps a reducer function to a specific action type. Declaration public void On<TAction>(Func<TState, TAction, TState> reducer) where TAction : IAction Parameters Type Name Description Func<TState, TAction, TState> reducer The reducer function that takes the state and action and returns a new state. Type Parameters Name Description TAction The type of the action. Exceptions Type Condition ArgumentNullException Thrown when the reducer is null. | Edit this page View Source On<TAction>(Func<TState>) Maps a reducer function to a specific action type. Declaration public void On<TAction>(Func<TState> reducer) Parameters Type Name Description Func<TState> reducer The reducer function that takes no arguments and returns a new state. Type Parameters Name Description TAction The type of the action. | Edit this page View Source Reduce(TState, IAction) Reduces the state using the appropriate reducer for the given action. Declaration public TState Reduce(TState state, IAction action) Parameters Type Name Description TState state The current state. IAction action The action to apply to the state. Returns Type Description TState The new state after applying the reducer, or the original state if no reducer is found. Exceptions Type Condition ArgumentNullException Thrown when the action is null. Implements ISlice<TState> ISlice IDisposable IEquatable<T>"
  },
  "reference/R3dux.StateChange-1.html": {
    "href": "reference/R3dux.StateChange-1.html",
    "title": "Class StateChange<TState> | R3dux Documentation",
    "keywords": "Class StateChange<TState> Represents a state change notification. Inheritance object StateChange<TState> Implements IEquatable<StateChange<TState>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public sealed record StateChange<TState> : IEquatable<StateChange<TState>> Type Parameters Name Description TState The type of the state. Constructors | Edit this page View Source StateChange(IAction, TState, TState, double) Represents a state change notification. Declaration public StateChange(IAction Action, TState PreviousState, TState NewState, double ElapsedMilliseconds) Parameters Type Name Description IAction Action The action causing the state change. TState PreviousState The previous state before the change. TState NewState The new state after the change. double ElapsedMilliseconds The time taken for the state change in milliseconds. Properties | Edit this page View Source Action The action causing the state change. Declaration public IAction Action { get; init; } Property Value Type Description IAction | Edit this page View Source ElapsedMilliseconds The time taken for the state change in milliseconds. Declaration public double ElapsedMilliseconds { get; init; } Property Value Type Description double | Edit this page View Source NewState The new state after the change. Declaration public TState NewState { get; init; } Property Value Type Description TState | Edit this page View Source PreviousState The previous state before the change. Declaration public TState PreviousState { get; init; } Property Value Type Description TState Implements IEquatable<T>"
  },
  "reference/R3dux.StateLoggerObserver-1.html": {
    "href": "reference/R3dux.StateLoggerObserver-1.html",
    "title": "Class StateLoggerObserver<TState> | R3dux Documentation",
    "keywords": "Class StateLoggerObserver<TState> Provides logging functionalities for state changes. Inheritance object Observer<StateChange<TState>> StateLoggerObserver<TState> Implements IDisposable Inherited Members Observer<StateChange<TState>>.OnNext(StateChange<TState>) Observer<StateChange<TState>>.OnErrorResume(Exception) Observer<StateChange<TState>>.OnCompleted(Result) Observer<StateChange<TState>>.Dispose() Observer<StateChange<TState>>.IsDisposed object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public sealed class StateLoggerObserver<TState> : Observer<StateChange<TState>>, IDisposable Type Parameters Name Description TState The type of the state. Methods | Edit this page View Source OnCompletedCore(Result) Handles the completion of the state change stream. Declaration protected override void OnCompletedCore(Result result) Parameters Type Name Description Result result The result of the state change stream. Overrides R3.Observer<R3dux.StateChange<TState>>.OnCompletedCore(R3.Result) | Edit this page View Source OnErrorResumeCore(Exception) Handles an error in the state change stream. Declaration protected override void OnErrorResumeCore(Exception error) Parameters Type Name Description Exception error The error encountered. Overrides Observer<StateChange<TState>>.OnErrorResumeCore(Exception) | Edit this page View Source OnNextCore(StateChange<TState>) Handles the reception of a state change notification. Declaration protected override void OnNextCore(StateChange<TState> value) Parameters Type Name Description StateChange<TState> value The state change notification. Overrides Observer<StateChange<TState>>.OnNextCore(StateChange<TState>) Implements IDisposable"
  },
  "reference/R3dux.StoreFactory.html": {
    "href": "reference/R3dux.StoreFactory.html",
    "title": "Class StoreFactory | R3dux Documentation",
    "keywords": "Class StoreFactory Factory for creating instances of R3duxStore. Inheritance object StoreFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public static class StoreFactory Methods | Edit this page View Source CreateStore(IDispatcher, ISlice[], IEffect[]) Creates a new instance of R3duxStore. Declaration public static R3duxStore CreateStore(IDispatcher dispatcher, ISlice[] slices, IEffect[] effects) Parameters Type Name Description IDispatcher dispatcher The dispatcher to be used by the store. ISlice[] slices The collection of slices to be added to the store. IEffect[] effects The collection of effects to be added to the store. Returns Type Description R3duxStore A new instance of R3duxStore."
  },
  "reference/R3dux.StoreInitialized.html": {
    "href": "reference/R3dux.StoreInitialized.html",
    "title": "Class StoreInitialized | R3dux Documentation",
    "keywords": "Class StoreInitialized Represents an action that is dispatched when the store is initialized. Inheritance object StoreInitialized Implements IKeyedAction IAction IEquatable<StoreInitialized> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: R3dux Assembly: R3dux.dll Syntax public sealed record StoreInitialized : IKeyedAction, IAction, IEquatable<StoreInitialized> Properties | Edit this page View Source TypeKey Gets the type of an action identifies to the consumer the nature of the action that has occurred. Declaration public string TypeKey { get; } Property Value Type Description string Implements IKeyedAction IAction IEquatable<T>"
  },
  "reference/R3dux.html": {
    "href": "reference/R3dux.html",
    "title": "Namespace R3dux | R3dux Documentation",
    "keywords": "Namespace R3dux Classes DependencyInjections Extension methods for adding R3dux services to the dependency injection container. Dispatcher A dispatcher that queues and dispatches actions, providing an observable stream of dispatched actions. Effect Supports all classes in the .NET class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all .NET classes; it is the root of the type hierarchy. LoggerProvider Provides a centralized mechanism to configure and obtain logger instances. ObservableSlices Manages a collection of observable slices and provides an observable root state. R3duxOptions Options for configuring R3dux services. R3duxStore Represents a store that manages application state and handles actions. RootState Represents the root state of the application, managing slice states. RootStateSerializer Provides methods for serializing and deserializing RootState instances. SliceReducers<TState> Represents a strongly-typed state slice with state management and reducers. StateChange<TState> Represents a state change notification. StateLoggerObserver<TState> Provides logging functionalities for state changes. StoreFactory Factory for creating instances of R3duxStore. StoreInitialized Represents an action that is dispatched when the store is initialized."
  },
  "services/README.html": {
    "href": "services/README.html",
    "title": "Services | R3dux Documentation",
    "keywords": "Services This folder contains documentation per service. Sample reference to the WeatherForecast class using xref:DotNetCoreSampleWebAPI.WeatherForecast."
  },
  "services/SampleService/README.html": {
    "href": "services/SampleService/README.html",
    "title": "Sample Service | R3dux Documentation",
    "keywords": "Sample Service This is the documentation of a sample service."
  }
}