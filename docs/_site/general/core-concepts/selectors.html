<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  <!-- Standard head.tmpl.partial from 'default' template. v2.63.1
   When you have rendering issues, check if this is the latest version
   with 'docfx template export default -o <path-to-a-local-folder>' -->

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Selectors | R3dux Documentation </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Selectors | R3dux Documentation ">
    
      <link rel="shortcut icon" href="../../images/favicon.ico">
      <link rel="stylesheet" href="../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../styles/docfx.css">
      <link rel="stylesheet" href="../../styles/main.css">
      <!-- Added support for copy code button. Together with script in scripts.tmpl.partial -->
      <link rel="stylesheet" href="../../styles/copy-code-button.css">
      <meta property="docfx:navrel" content="../../toc.html">
      <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/logo.png" alt="R3dux Documentation">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="selectors">Selectors</h1>

<p>Selectors in R3dux are functions that allow you to extract and compute derived data from the global state. They encapsulate the logic for retrieving specific pieces of data and can be used to optimize performance by minimizing unnecessary recalculations.</p>
<h2 id="what-are-selectors">What are Selectors?</h2>
<p>Selectors are specialized functions designed to query and derive specific data from the state. They help you avoid duplicating logic across components and can improve performance by memoizing computed values, ensuring that they are only recalculated when necessary.</p>
<h3 id="key-characteristics-of-selectors">Key Characteristics of Selectors</h3>
<ol>
<li><strong>Encapsulation</strong>: Selectors encapsulate the logic for selecting data from the state, making your components simpler and more focused.</li>
<li><strong>Reusability</strong>: Since selectors are functions, they can be reused across different parts of your application.</li>
<li><strong>Memoization</strong>: Selectors can be memoized to prevent unnecessary recalculations, which can significantly improve performance in large applications.</li>
</ol>
<h2 id="basic-selectors">Basic Selectors</h2>
<p>Selectors can be defined as methods within your state classes. These methods are responsible for querying the state and returning the relevant data.</p>
<h3 id="example-basic-selectors">Example: Basic Selectors</h3>
<p>Here’s an example of a <code>MoviesState</code> record with basic selectors:</p>
<pre><code class="lang-csharp">public record MoviesState
{
    public required ImmutableDictionary&lt;int, Movie&gt; Movies { get; init; }

    public required bool IsLoading { get; init; }

    public required string? ErrorMessage { get; init; }

    public required Pagination Pagination { get; init; }

    // Selectors
    // ==========
    // Selectors are defined as methods that encapsulate the logic of selecting data from the state.
    // Each method should begin with the word &quot;Select&quot;.
    
    public int SelectMovieCount()
    {
        return Movies.Count;
    }

    public Movie? SelectMovieById(int id)
    {
        return Movies.GetValueOrDefault(id);
    }

    public ImmutableDictionary&lt;int, Movie&gt; SelectMoviesByYear()
    {
        return Movies
            .OrderByDescending(pair =&gt; pair.Value.Year)
            .ToImmutableDictionary();
    }
}
</code></pre>
<p>In this example:</p>
<ul>
<li>The <code>SelectMovieCount</code> selector returns the total number of movies.</li>
<li>The <code>SelectMovieById</code> selector retrieves a movie by its ID.</li>
<li>The <code>SelectMoviesByYear</code> selector returns the movies sorted by their release year in descending order.</li>
</ul>
<h2 id="advanced-selectors">Advanced Selectors</h2>
<p>As your application grows, you might need more advanced selectors that can handle complex queries or derived data. R3dux allows you to create <strong>memoized selectors</strong> that cache their results and recalculate only when the relevant parts of the state have changed.</p>
<h3 id="example-advanced-selectors-with-memoization">Example: Advanced Selectors with Memoization</h3>
<p>Here’s an example of a <code>ProductState</code> record that uses memoized selectors:</p>
<pre><code class="lang-csharp">public record ProductState : NormalizedState&lt;Guid, Product, ProductState&gt;
{
    private readonly Func&lt;ProductState, ImmutableList&lt;Product&gt;&gt; _selectElectronics;
    private readonly Func&lt;ProductState, ImmutableList&lt;Product&gt;&gt; _selectClothing;
    private readonly Func&lt;ProductState, decimal&gt; _selectTotalPriceOfElectronics;
    private readonly Func&lt;ProductState, decimal&gt; _selectTotalPriceOfClothing;

    public ProductState()
    {
        _selectElectronics = MemoizedSelector.Create&lt;ProductState, ImmutableList&lt;Product&gt;&gt;(
            state =&gt; state.SelectImmutableList(product =&gt; product.Category == &quot;Electronics&quot;),
            state =&gt; state.ById);

        _selectClothing = MemoizedSelector.Create&lt;ProductState, ImmutableList&lt;Product&gt;&gt;(
            state =&gt; state.SelectImmutableList(product =&gt; product.Category == &quot;Clothing&quot;),
            state =&gt; state.ById);

        _selectTotalPriceOfElectronics = MemoizedSelector.Compose(
            _selectElectronics,
            products =&gt; products.Sum(product =&gt; product.Price),
            state =&gt; state.ById);

        _selectTotalPriceOfClothing = MemoizedSelector.Compose(
            _selectClothing,
            products =&gt; products.Sum(product =&gt; product.Price),
            state =&gt; state.ById);
    }

    // Memoized Selectors
    public ImmutableList&lt;Product&gt; SelectElectronics()
    {
        return _selectElectronics(this);
    }

    public ImmutableList&lt;Product&gt; SelectClothing()
    {
        return _selectClothing(this);
    }

    public decimal SelectTotalPriceOfElectronics()
    {
        return _selectTotalPriceOfElectronics(this);
    }

    public decimal SelectTotalPriceOfClothing()
    {
        return _selectTotalPriceOfClothing(this);
    }
}
</code></pre>
<p>In this example:</p>
<ul>
<li><strong>Memoized Selectors</strong>: The selectors are memoized using the <code>MemoizedSelector.Create</code> and <code>MemoizedSelector.Compose</code> methods to avoid unnecessary recomputation.</li>
<li><strong>Advanced Queries</strong>: The <code>SelectElectronics</code> and <code>SelectClothing</code> selectors return lists of products filtered by category.</li>
<li><strong>Derived Data</strong>: The <code>SelectTotalPriceOfElectronics</code> and <code>SelectTotalPriceOfClothing</code> selectors compute the total price of products in each category, leveraging memoization to enhance performance.</li>
</ul>
<h2 id="using-selectors-in-blazor-components">Using Selectors in Blazor Components</h2>
<p>A best practice when using selectors in Blazor components is to create properties that use the selectors, keeping the component's markup separate from its logic. This approach makes your components more maintainable and easier to read.</p>
<h3 id="example-using-selectors-in-a-blazor-component">Example: Using Selectors in a Blazor Component</h3>
<p>Here’s an example of a Blazor component that uses selectors to manage a Todo list:</p>
<pre><code class="lang-html">@page &quot;/todo&quot;
@inherits R3duxComponent&lt;TodoState&gt;

&lt;PageTitle&gt;R3dux - Todo List&lt;/PageTitle&gt;

&lt;MudGrid&gt;
  &lt;MudItem xs=&quot;12&quot;&gt;
    &lt;MudStack&gt;
      &lt;MudText Typo=&quot;Typo.subtitle1&quot;&gt;Example&lt;/MudText&gt;
      &lt;MudText Typo=&quot;Typo.h3&quot;&gt;Todo List&lt;/MudText&gt;
      &lt;MudText Typo=&quot;Typo.body1&quot;&gt;
        Manage your todos effectively with R3dux, featuring functionality to add, toggle, and remove todo items.
      &lt;/MudText&gt;
    &lt;/MudStack&gt;
  &lt;/MudItem&gt;

  &lt;MudItem xs=&quot;12&quot; lg=&quot;6&quot;&gt;
    &lt;MudStack&gt;
      &lt;MudBadge Content=&quot;@ActiveTodosCount&quot; Color=&quot;Color.Primary&quot;&gt;
        &lt;MudText Typo=&quot;Typo.h5&quot;&gt;Active Todos&lt;/MudText&gt;
      &lt;/MudBadge&gt;
      
      &lt;MudPaper&gt;
        @if (!HasActiveTodos)
        {
          &lt;MudText Typo=&quot;Typo.h6&quot; Class=&quot;ma-4&quot;&gt;
            No active todos - add a new todo item to get started!
          &lt;/MudText&gt;
        }
        &lt;MudList T=&quot;TodoItem&quot;&gt;
          @foreach (var todo in ActiveTodos)
          {
            &lt;MudListItem @key=&quot;todo.Id&quot;&gt;
              &lt;MudStack Row Justify=&quot;Justify.SpaceBetween&quot; AlignItems=&quot;AlignItems.Center&quot;&gt;
                &lt;MudIconButton Icon=&quot;@Icons.Material.Filled.CheckBoxOutlineBlank&quot; OnClick=&quot;() =&gt; ToggleTodoItem(todo.Id)&quot;/&gt;
                &lt;MudText&gt;@todo.Title&lt;/MudText&gt;
                &lt;MudSpacer/&gt;
                &lt;MudButton Variant=&quot;Variant.Outlined&quot; Color=&quot;Color.Error&quot; OnClick=&quot;() =&gt; DeleteTodoItem(todo.Id)&quot;&gt;Delete&lt;/MudButton&gt;
              &lt;/MudStack&gt;
            &lt;/MudListItem&gt;
          }
        &lt;/MudList&gt;
      &lt;/MudPaper&gt;

      &lt;MudCard&gt;
        &lt;MudCardContent&gt;
          &lt;MudTextField @bind-Value=&quot;_newTodo&quot; Variant=&quot;Variant.Filled&quot; Label=&quot;New Todo&quot; /&gt;
        &lt;/MudCardContent&gt;
        &lt;MudCardActions&gt;
          &lt;MudButton Variant=&quot;Variant.Outlined&quot; OnClick=&quot;CreateTodoItem&quot;&gt;Add Todo&lt;/MudButton&gt;
        &lt;/MudCardActions&gt;
      &lt;/MudCard&gt;
    &lt;/MudStack&gt;
  &lt;/MudItem&gt;

  &lt;MudItem xs=&quot;12&quot; lg=&quot;6&quot;&gt;
    &lt;MudStack&gt;
      &lt;MudBadge Content=&quot;@CompletedTodosCount&quot; Color=&quot;Color.Secondary&quot;&gt;
        &lt;MudText Typo=&quot;Typo.h5&quot;&gt;Completed Todos&lt;/MudText&gt;
      &lt;/MudBadge&gt;
      &lt;MudPaper&gt;
        &lt;MudList T=&quot;TodoItem&quot;&gt;
          @foreach (var todo in CompletedTodos)
          {
            &lt;MudListItem @key=&quot;todo.Id&quot;&gt;
              &lt;MudStack Row Justify=&quot;Justify.SpaceBetween&quot; AlignItems=&quot;AlignItems.Center&quot;&gt;
                &lt;MudIconButton Icon=&quot;@Icons.Material.Filled.CheckBox&quot; OnClick=&quot;() =&gt; ToggleTodoItem(todo.Id)&quot;/&gt;
                &lt;MudText Style=&quot;text-decoration: line-through;&quot;&gt;@todo.Title&lt;/MudText&gt;
                &lt;MudSpacer/&gt;
                &lt;MudButton Variant=&quot;Variant.Outlined&quot; Color=&quot;Color.Error&quot; OnClick=&quot;() =&gt; DeleteTodoItem(todo.Id)&quot;&gt;Delete&lt;/MudButton&gt;
              &lt;/MudStack&gt;
            &lt;/MudListItem&gt;
          }
        &lt;/MudList&gt;
      &lt;/MudPaper&gt;
    &lt;/MudStack&gt;
  &lt;/MudItem&gt;
&lt;/MudGrid&gt;

@code {

  private string _newTodo = string.Empty;

  // Using Selectors as Properties
  private ImmutableList&lt;TodoItem&gt; ActiveTodos =&gt; State.SelectActiveTodos();
  private int ActiveTodosCount =&gt; State.SelectActiveTodosCount();
  private bool HasActiveTodos =&gt; State.SelectActiveTodosCount() &gt; 0;
  
  private ImmutableList&lt;TodoItem&gt; CompletedTodos =&gt; State.SelectCompletedTodos();
  private int CompletedTodosCount =&gt; State.SelectCompletedTodosCount();

  private void CreateTodoItem()
  {
      if (!string.IsNullOrWhiteSpace(_newTodo))
      {
          Dispatch(new CreateTodoItem(_newTodo));
          _newTodo = string.Empty;
      }
  }

  private void ToggleTodoItem(Guid id)
  {
      Dispatch(new ToggleTodoItem(id));
  }

  private void DeleteTodoItem(Guid id)
  {
      Dispatch(new DeleteTodoItem(id));
  }
}
</code></pre>
<p>In this example:</p>
<ul>
<li><strong>Selectors as Properties</strong>: The component defines properties like <code>ActiveTodos</code>, <code>ActiveTodosCount</code>, and <code>HasActiveTodos</code> that use selectors to access state. This keeps the markup clean and the logic encapsulated.</li>
<li><strong>Clean Markup</strong>: The component’s markup is clean and focused on UI elements, with the business logic separated into the <code>@code</code> section.</li>
<li><strong>Reusability</strong>: The selector-based properties can be reused in other components, promoting consistency and reducing code duplication.</li>
</ul>
<h2 id="best-practices-for-using-selectors-in-blazor">Best Practices for Using Selectors in Blazor</h2>
<ul>
<li><strong>Encapsulate Logic</strong>: Use selectors within your state classes to encapsulate data retrieval logic, keeping your components focused on rendering UI.</li>
<li><strong>Separate Markup and Logic</strong>: Define properties in your components that use selectors. This approach keeps your Razor markup clean and easy to maintain.</li>
<li><strong>Leverage Memoization</strong>: For expensive computations or derived data, use memoized selectors to optimize performance.</li>
<li><strong>Reusability</strong>: Reuse selectors across your application to maintain consistency and avoid duplicating logic.</li>
</ul>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/phmatray/R3dux/blob/features/documentation/docs/general/core-concepts/selectors.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    <!-- Standard scripts.tmpl.partial from 'default' template. v2.63.1
     When you have rendering issues, check if this is the latest version
     with 'docfx template export default -o <path-to-a-local-folder>' -->

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>

    <!-- Added support for copy code button. Together with script in scripts.tmpl.partial -->
    <script type="text/javascript" src="../../styles/copy-code-button.js"></script>

    <!-- Support for diagrams (Mermaid). See https://mermaid.js.org/intro/n00b-gettingStarted.html -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
    </script>  </body>
</html>
