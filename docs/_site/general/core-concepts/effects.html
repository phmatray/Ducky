<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  <!-- Standard head.tmpl.partial from 'default' template. v2.63.1
   When you have rendering issues, check if this is the latest version
   with 'docfx template export default -o <path-to-a-local-folder>' -->

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Effects | R3dux Documentation </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Effects | R3dux Documentation ">
    
      <link rel="shortcut icon" href="../../images/favicon.ico">
      <link rel="stylesheet" href="../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../styles/docfx.css">
      <link rel="stylesheet" href="../../styles/main.css">
      <!-- Added support for copy code button. Together with script in scripts.tmpl.partial -->
      <link rel="stylesheet" href="../../styles/copy-code-button.css">
      <meta property="docfx:navrel" content="../../toc.html">
      <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/logo.png" alt="R3dux Documentation">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="effects">Effects</h1>

<p>In R3dux, effects are a powerful tool for handling side effects—operations that interact with the outside world or involve asynchronous logic. Effects listen to the stream of actions dispatched to the store and can dispatch new actions based on the outcome of those operations, such as API calls, logging, or timers.</p>
<h2 id="what-are-effects">What are Effects?</h2>
<p>Effects are responsible for managing side effects in your application. Unlike reducers, which handle pure state transformations, effects are used to perform operations that have side effects, such as:</p>
<ul>
<li>Making asynchronous API calls.</li>
<li>Dispatching notifications.</li>
<li>Handling time-based events (like timers).</li>
<li>Interacting with services outside of your state management logic.</li>
</ul>
<h3 id="key-characteristics-of-effects">Key Characteristics of Effects</h3>
<ol>
<li><strong>Asynchronous Operations</strong>: Effects can handle asynchronous operations such as API calls, allowing your application to interact with external services or data sources.</li>
<li><strong>Dispatching New Actions</strong>: Based on the outcome of the side effect, effects can dispatch new actions to update the state.</li>
<li><strong>Separation of Concerns</strong>: Effects keep side effects separate from reducers, ensuring that state transformations remain pure and predictable.</li>
</ol>
<h2 id="defining-effects">Defining Effects</h2>
<p>In R3dux, you define an effect by extending the <code>Effect</code> class and overriding the <code>Handle</code> method. The <code>Handle</code> method takes two parameters:</p>
<ul>
<li><code>Observable&lt;IAction&gt; actions</code>: The stream of actions dispatched to the store.</li>
<li><code>Observable&lt;IRootState&gt; rootState</code>: The observable stream of the current state.</li>
</ul>
<h3 id="example-loading-movies-with-an-api-call">Example: Loading Movies with an API Call</h3>
<p>Here’s an example of an effect that handles loading movies from an external API:</p>
<pre><code class="lang-csharp">public class LoadMoviesEffect : Effect
{
    private readonly IMoviesService _moviesService;

    public LoadMoviesEffect(IMoviesService moviesService)
    {
        _moviesService = moviesService;
    }

    public override Observable&lt;IAction&gt; Handle(
        Observable&lt;IAction&gt; actions,
        Observable&lt;IRootState&gt; rootState)
    {
        return actions
            .OfType&lt;LoadMovies&gt;()
            .LogMessage(&quot;Loading movies...&quot;)
            .WithSliceState&lt;MoviesState, LoadMovies&gt;(rootState)
            .InvokeService(
                pair =&gt; _moviesService.GetMoviesAsync(pair.State.Pagination.CurrentPage, 5),
                response =&gt; new LoadMoviesSuccess(response.Movies, response.TotalItems),
                ex =&gt; new LoadMoviesFailure(ex))
            .LogMessage(&quot;Movies loaded.&quot;);
    }
}
</code></pre>
<p>In this example:</p>
<ul>
<li>The <code>LoadMoviesEffect</code> listens for the <code>LoadMovies</code> action.</li>
<li>It logs the action, retrieves the current state slice, and invokes the <code>GetMoviesAsync</code> method from <code>IMoviesService</code>.</li>
<li>Based on the API response, it dispatches either <code>LoadMoviesSuccess</code> or <code>LoadMoviesFailure</code> actions.</li>
</ul>
<h3 id="example-displaying-notifications-after-a-successful-load">Example: Displaying Notifications After a Successful Load</h3>
<p>This example demonstrates how to use an effect to display a success notification after movies are successfully loaded:</p>
<pre><code class="lang-csharp">public class LoadMoviesSuccessEffect : Effect
{
    private readonly ISnackbar _snackbar;

    public LoadMoviesSuccessEffect(ISnackbar snackbar)
    {
        _snackbar = snackbar;
    }

    public override Observable&lt;IAction&gt; Handle(
        Observable&lt;IAction&gt; actions, Observable&lt;IRootState&gt; rootState)
    {
        return actions
            .OfType&lt;IAction, LoadMoviesSuccess&gt;()
            .Select(GetSnackBarMessage)
            .Do(message =&gt; _snackbar.Add(message, Severity.Success))
            .Select(message =&gt;
            {
                var notification = new SuccessNotification(message);
                return (IAction)new AddNotification(notification);
            });
    }

    private static string GetSnackBarMessage(LoadMoviesSuccess action)
    {
        return $&quot;Loaded {action.Movies.Length} movies from the server.&quot;;
    }
}
</code></pre>
<p>In this example:</p>
<ul>
<li>The <code>LoadMoviesSuccessEffect</code> listens for the <code>LoadMoviesSuccess</code> action.</li>
<li>It generates a success message and displays it using the <code>ISnackbar</code> service.</li>
<li>After displaying the notification, it dispatches a new <code>AddNotification</code> action.</li>
</ul>
<h3 id="example-handling-timers">Example: Handling Timers</h3>
<p>Effects are also useful for handling time-based operations, such as starting and stopping timers. Here's an example of an effect that handles a timer:</p>
<pre><code class="lang-csharp">public class StartTimerEffect : Effect
{
    public override Observable&lt;IAction&gt; Handle(
        Observable&lt;IAction&gt; actions,
        Observable&lt;IRootState&gt; rootState)
    {
        return actions
            .OfType&lt;StartTimer&gt;()
            .SwitchSelect(_ =&gt; Observable
                .Interval(TimeSpan.FromSeconds(1), TimeProvider)
                .Select(_ =&gt; new Tick())
                .TakeUntil(actions.OfType&lt;StopTimer&gt;())
                .Cast&lt;Tick, IAction&gt;());
    }
}
</code></pre>
<p>In this example:</p>
<ul>
<li>The <code>StartTimerEffect</code> listens for the <code>StartTimer</code> action.</li>
<li>It starts a timer that dispatches a <code>Tick</code> action every second.</li>
<li>The timer stops when a <code>StopTimer</code> action is dispatched.</li>
</ul>
<h2 id="custom-operators-in-effects">Custom Operators in Effects</h2>
<p>R3dux provides several custom operators to simplify common patterns in effects, such as filtering actions, invoking services, and handling errors.</p>
<h3 id="key-operators">Key Operators</h3>
<ul>
<li><strong>OfType</strong>: Filters actions of a specific type.</li>
<li><strong>WithSliceState</strong>: Combines actions with the corresponding slice of the state.</li>
<li><strong>InvokeService</strong>: Handles calling external services and dispatching success or error actions based on the outcome.</li>
</ul>
<h3 id="example-using-custom-operators">Example: Using Custom Operators</h3>
<pre><code class="lang-csharp">public override Observable&lt;IAction&gt; Handle(
    Observable&lt;IAction&gt; actions,
    Observable&lt;IRootState&gt; rootState)
{
    return actions
        .OfType&lt;LoadMovies&gt;()
        .WithSliceState&lt;MoviesState, LoadMovies&gt;(rootState)
        .InvokeService(
            pair =&gt; _moviesService.GetMoviesAsync(pair.State.Pagination.CurrentPage, 5),
            response =&gt; new LoadMoviesSuccess(response.Movies, response.TotalItems),
            ex =&gt; new LoadMoviesFailure(ex));
}
</code></pre>
<p>This code demonstrates how custom operators streamline the process of handling actions, accessing state, and performing service calls.</p>
<h2 id="best-practices-for-writing-effects">Best Practices for Writing Effects</h2>
<ul>
<li><strong>Keep Effects Focused</strong>: Each effect should handle a specific side effect, such as an API call or a timer. This makes effects easier to manage and test.</li>
<li><strong>Use Custom Operators</strong>: Leverage R3dux’s custom operators to simplify your effect logic and make it more readable.</li>
<li><strong>Handle Errors Gracefully</strong>: Always handle potential errors in your effects by dispatching appropriate failure actions.</li>
<li><strong>Avoid Side Effects in Reducers</strong>: Use effects, not reducers, for handling side effects. Reducers should remain pure and only manage state transformations.</li>
</ul>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/phmatray/R3dux/blob/features/documentation/docs/general/core-concepts/effects.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    <!-- Standard scripts.tmpl.partial from 'default' template. v2.63.1
     When you have rendering issues, check if this is the latest version
     with 'docfx template export default -o <path-to-a-local-folder>' -->

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>

    <!-- Added support for copy code button. Together with script in scripts.tmpl.partial -->
    <script type="text/javascript" src="../../styles/copy-code-button.js"></script>

    <!-- Support for diagrams (Mermaid). See https://mermaid.js.org/intro/n00b-gettingStarted.html -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
    </script>  </body>
</html>
